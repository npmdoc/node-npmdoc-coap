<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/mcollina/node-coap#readme"

    >coap (v0.21.0)</a>
</h1>
<h4>A CoAP library for node modelled after 'http'</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.coap">module coap</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.Agent">
            function <span class="apidocSignatureSpan">coap.</span>Agent
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.Agent.prototype._cleanUp">
            function <span class="apidocSignatureSpan">coap.</span>Agent.prototype._cleanUp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.Agent.prototype._doClose">
            function <span class="apidocSignatureSpan">coap.</span>Agent.prototype._doClose
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.Agent.prototype._handle">
            function <span class="apidocSignatureSpan">coap.</span>Agent.prototype._handle
            <span class="apidocSignatureSpan">(msg, rsinfo, outSocket)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.Agent.prototype._init">
            function <span class="apidocSignatureSpan">coap.</span>Agent.prototype._init
            <span class="apidocSignatureSpan">(socket)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.Agent.prototype._nextMessageId">
            function <span class="apidocSignatureSpan">coap.</span>Agent.prototype._nextMessageId
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.Agent.prototype._nextToken">
            function <span class="apidocSignatureSpan">coap.</span>Agent.prototype._nextToken
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.Agent.prototype.abort">
            function <span class="apidocSignatureSpan">coap.</span>Agent.prototype.abort
            <span class="apidocSignatureSpan">(req)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.Agent.prototype.request">
            function <span class="apidocSignatureSpan">coap.</span>Agent.prototype.request
            <span class="apidocSignatureSpan">(url)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.createServer">
            function <span class="apidocSignatureSpan">coap.</span>createServer
            <span class="apidocSignatureSpan">(options, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.createServer.prototype._handle">
            function <span class="apidocSignatureSpan">coap.</span>createServer.prototype._handle
            <span class="apidocSignatureSpan">(packet, rsinfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.createServer.prototype._sendError">
            function <span class="apidocSignatureSpan">coap.</span>createServer.prototype._sendError
            <span class="apidocSignatureSpan">(payload, rsinfo, packet)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.createServer.prototype._sendProxied">
            function <span class="apidocSignatureSpan">coap.</span>createServer.prototype._sendProxied
            <span class="apidocSignatureSpan">(packet, proxyUri, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.createServer.prototype._sendReverseProxied">
            function <span class="apidocSignatureSpan">coap.</span>createServer.prototype._sendReverseProxied
            <span class="apidocSignatureSpan">(packet, rsinfo, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.createServer.prototype.close">
            function <span class="apidocSignatureSpan">coap.</span>createServer.prototype.close
            <span class="apidocSignatureSpan">(done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.createServer.prototype.listen">
            function <span class="apidocSignatureSpan">coap.</span>createServer.prototype.listen
            <span class="apidocSignatureSpan">(port, address, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.defaultTiming">
            function <span class="apidocSignatureSpan">coap.</span>defaultTiming
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.ignoreOption">
            function <span class="apidocSignatureSpan">coap.</span>ignoreOption
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.incoming_message">
            function <span class="apidocSignatureSpan">coap.</span>incoming_message
            <span class="apidocSignatureSpan">(packet, rsinfo, outSocket)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.observe_read_stream">
            function <span class="apidocSignatureSpan">coap.</span>observe_read_stream
            <span class="apidocSignatureSpan">(packet, rsinfo, outSocket)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.observe_write_stream">
            function <span class="apidocSignatureSpan">coap.</span>observe_write_stream
            <span class="apidocSignatureSpan">(request, send)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.outgoing_message">
            function <span class="apidocSignatureSpan">coap.</span>outgoing_message
            <span class="apidocSignatureSpan">(request, send)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.registerFormat">
            function <span class="apidocSignatureSpan">coap.</span>registerFormat
            <span class="apidocSignatureSpan">(name, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.registerOption">
            function <span class="apidocSignatureSpan">coap.</span>registerOption
            <span class="apidocSignatureSpan">(name, toBinary, fromBinary)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.request">
            function <span class="apidocSignatureSpan">coap.</span>request
            <span class="apidocSignatureSpan">(url)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.retry_send">
            function <span class="apidocSignatureSpan">coap.</span>retry_send
            <span class="apidocSignatureSpan">(sock, port, host)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.updateTiming">
            function <span class="apidocSignatureSpan">coap.</span>updateTiming
            <span class="apidocSignatureSpan">(values)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">coap.</span>Agent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">coap.</span>createServer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">coap.</span>globalAgent</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">coap.</span>globalAgentIPv6</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">coap.</span>helpers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">coap.</span>incoming_message.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">coap.</span>middlewares</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">coap.</span>observe_read_stream.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">coap.</span>observe_write_stream.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">coap.</span>option_converter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">coap.</span>outgoing_message.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">coap.</span>parameters</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">coap.</span>polyfill</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">coap.</span>retry_send.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.coap.Agent">module coap.Agent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.Agent.Agent">
            function <span class="apidocSignatureSpan">coap.</span>Agent
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.Agent.super_">
            function <span class="apidocSignatureSpan">coap.Agent.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.coap.Agent.prototype">module coap.Agent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.Agent.prototype._cleanUp">
            function <span class="apidocSignatureSpan">coap.Agent.prototype.</span>_cleanUp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.Agent.prototype._doClose">
            function <span class="apidocSignatureSpan">coap.Agent.prototype.</span>_doClose
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.Agent.prototype._handle">
            function <span class="apidocSignatureSpan">coap.Agent.prototype.</span>_handle
            <span class="apidocSignatureSpan">(msg, rsinfo, outSocket)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.Agent.prototype._init">
            function <span class="apidocSignatureSpan">coap.Agent.prototype.</span>_init
            <span class="apidocSignatureSpan">(socket)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.Agent.prototype._nextMessageId">
            function <span class="apidocSignatureSpan">coap.Agent.prototype.</span>_nextMessageId
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.Agent.prototype._nextToken">
            function <span class="apidocSignatureSpan">coap.Agent.prototype.</span>_nextToken
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.Agent.prototype.abort">
            function <span class="apidocSignatureSpan">coap.Agent.prototype.</span>abort
            <span class="apidocSignatureSpan">(req)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.Agent.prototype.request">
            function <span class="apidocSignatureSpan">coap.Agent.prototype.</span>request
            <span class="apidocSignatureSpan">(url)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.coap.Agent.prototype._cleanUp">module coap.Agent.prototype._cleanUp</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.Agent.prototype._cleanUp._cleanUp">
            function <span class="apidocSignatureSpan">coap.Agent.prototype.</span>_cleanUp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.coap.Agent.prototype._doClose">module coap.Agent.prototype._doClose</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.Agent.prototype._doClose._doClose">
            function <span class="apidocSignatureSpan">coap.Agent.prototype.</span>_doClose
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.coap.Agent.prototype._handle">module coap.Agent.prototype._handle</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.Agent.prototype._handle._handle">
            function <span class="apidocSignatureSpan">coap.Agent.prototype.</span>_handle
            <span class="apidocSignatureSpan">(msg, rsinfo, outSocket)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.coap.Agent.prototype._init">module coap.Agent.prototype._init</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.Agent.prototype._init._init">
            function <span class="apidocSignatureSpan">coap.Agent.prototype.</span>_init
            <span class="apidocSignatureSpan">(socket)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.coap.Agent.prototype._nextMessageId">module coap.Agent.prototype._nextMessageId</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.Agent.prototype._nextMessageId._nextMessageId">
            function <span class="apidocSignatureSpan">coap.Agent.prototype.</span>_nextMessageId
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.coap.Agent.prototype._nextToken">module coap.Agent.prototype._nextToken</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.Agent.prototype._nextToken._nextToken">
            function <span class="apidocSignatureSpan">coap.Agent.prototype.</span>_nextToken
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.coap.Agent.prototype.abort">module coap.Agent.prototype.abort</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.Agent.prototype.abort.abort">
            function <span class="apidocSignatureSpan">coap.Agent.prototype.</span>abort
            <span class="apidocSignatureSpan">(req)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.coap.Agent.prototype.request">module coap.Agent.prototype.request</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.Agent.prototype.request.request">
            function <span class="apidocSignatureSpan">coap.Agent.prototype.</span>request
            <span class="apidocSignatureSpan">(url)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.coap.createServer">module coap.createServer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.createServer.createServer">
            function <span class="apidocSignatureSpan">coap.</span>createServer
            <span class="apidocSignatureSpan">(options, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.createServer.super_">
            function <span class="apidocSignatureSpan">coap.createServer.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.coap.createServer.prototype">module coap.createServer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.createServer.prototype._handle">
            function <span class="apidocSignatureSpan">coap.createServer.prototype.</span>_handle
            <span class="apidocSignatureSpan">(packet, rsinfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.createServer.prototype._sendError">
            function <span class="apidocSignatureSpan">coap.createServer.prototype.</span>_sendError
            <span class="apidocSignatureSpan">(payload, rsinfo, packet)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.createServer.prototype._sendProxied">
            function <span class="apidocSignatureSpan">coap.createServer.prototype.</span>_sendProxied
            <span class="apidocSignatureSpan">(packet, proxyUri, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.createServer.prototype._sendReverseProxied">
            function <span class="apidocSignatureSpan">coap.createServer.prototype.</span>_sendReverseProxied
            <span class="apidocSignatureSpan">(packet, rsinfo, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.createServer.prototype.close">
            function <span class="apidocSignatureSpan">coap.createServer.prototype.</span>close
            <span class="apidocSignatureSpan">(done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.createServer.prototype.listen">
            function <span class="apidocSignatureSpan">coap.createServer.prototype.</span>listen
            <span class="apidocSignatureSpan">(port, address, done)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.coap.createServer.prototype._handle">module coap.createServer.prototype._handle</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.createServer.prototype._handle._handle">
            function <span class="apidocSignatureSpan">coap.createServer.prototype.</span>_handle
            <span class="apidocSignatureSpan">(packet, rsinfo)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.coap.createServer.prototype._sendError">module coap.createServer.prototype._sendError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.createServer.prototype._sendError._sendError">
            function <span class="apidocSignatureSpan">coap.createServer.prototype.</span>_sendError
            <span class="apidocSignatureSpan">(payload, rsinfo, packet)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.coap.createServer.prototype._sendProxied">module coap.createServer.prototype._sendProxied</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.createServer.prototype._sendProxied._sendProxied">
            function <span class="apidocSignatureSpan">coap.createServer.prototype.</span>_sendProxied
            <span class="apidocSignatureSpan">(packet, proxyUri, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.coap.createServer.prototype._sendReverseProxied">module coap.createServer.prototype._sendReverseProxied</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.createServer.prototype._sendReverseProxied._sendReverseProxied">
            function <span class="apidocSignatureSpan">coap.createServer.prototype.</span>_sendReverseProxied
            <span class="apidocSignatureSpan">(packet, rsinfo, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.coap.createServer.prototype.close">module coap.createServer.prototype.close</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.createServer.prototype.close.close">
            function <span class="apidocSignatureSpan">coap.createServer.prototype.</span>close
            <span class="apidocSignatureSpan">(done)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.coap.createServer.prototype.listen">module coap.createServer.prototype.listen</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.createServer.prototype.listen.listen">
            function <span class="apidocSignatureSpan">coap.createServer.prototype.</span>listen
            <span class="apidocSignatureSpan">(port, address, done)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.coap.defaultTiming">module coap.defaultTiming</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.defaultTiming.defaultTiming">
            function <span class="apidocSignatureSpan">coap.</span>defaultTiming
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.coap.helpers">module coap.helpers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.helpers.addSetOption">
            function <span class="apidocSignatureSpan">coap.helpers.</span>addSetOption
            <span class="apidocSignatureSpan">(klass)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.helpers.createBlock2">
            function <span class="apidocSignatureSpan">coap.helpers.</span>createBlock2
            <span class="apidocSignatureSpan">(requestedBlock)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.helpers.genAck">
            function <span class="apidocSignatureSpan">coap.helpers.</span>genAck
            <span class="apidocSignatureSpan">(request)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.helpers.getOption">
            function <span class="apidocSignatureSpan">coap.helpers.</span>getOption
            <span class="apidocSignatureSpan">(options, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.helpers.isBoolean">
            function <span class="apidocSignatureSpan">coap.helpers.</span>isBoolean
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.helpers.isNumeric">
            function <span class="apidocSignatureSpan">coap.helpers.</span>isNumeric
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.helpers.isOption">
            function <span class="apidocSignatureSpan">coap.helpers.</span>isOption
            <span class="apidocSignatureSpan">(optionName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.helpers.or">
            function <span class="apidocSignatureSpan">coap.helpers.</span>or
            <span class="apidocSignatureSpan">(previous, current)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.helpers.packetToMessage">
            function <span class="apidocSignatureSpan">coap.helpers.</span>packetToMessage
            <span class="apidocSignatureSpan">(dest, packet)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.helpers.parseBlock2">
            function <span class="apidocSignatureSpan">coap.helpers.</span>parseBlock2
            <span class="apidocSignatureSpan">(block2Value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.helpers.toCode">
            function <span class="apidocSignatureSpan">coap.helpers.</span>toCode
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.coap.ignoreOption">module coap.ignoreOption</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.ignoreOption.ignoreOption">
            function <span class="apidocSignatureSpan">coap.</span>ignoreOption
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.coap.incoming_message">module coap.incoming_message</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.incoming_message.incoming_message">
            function <span class="apidocSignatureSpan">coap.</span>incoming_message
            <span class="apidocSignatureSpan">(packet, rsinfo, outSocket)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.incoming_message.super_">
            function <span class="apidocSignatureSpan">coap.incoming_message.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.coap.incoming_message.prototype">module coap.incoming_message.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.incoming_message.prototype._read">
            function <span class="apidocSignatureSpan">coap.incoming_message.prototype.</span>_read
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.coap.middlewares">module coap.middlewares</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.middlewares.handleProxyResponse">
            function <span class="apidocSignatureSpan">coap.middlewares.</span>handleProxyResponse
            <span class="apidocSignatureSpan">(request, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.middlewares.handleServerRequest">
            function <span class="apidocSignatureSpan">coap.middlewares.</span>handleServerRequest
            <span class="apidocSignatureSpan">(request, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.middlewares.parseRequest">
            function <span class="apidocSignatureSpan">coap.middlewares.</span>parseRequest
            <span class="apidocSignatureSpan">(request, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.middlewares.proxyRequest">
            function <span class="apidocSignatureSpan">coap.middlewares.</span>proxyRequest
            <span class="apidocSignatureSpan">(request, next)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.coap.observe_read_stream">module coap.observe_read_stream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.observe_read_stream.observe_read_stream">
            function <span class="apidocSignatureSpan">coap.</span>observe_read_stream
            <span class="apidocSignatureSpan">(packet, rsinfo, outSocket)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.observe_read_stream.super_">
            function <span class="apidocSignatureSpan">coap.observe_read_stream.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.coap.observe_read_stream.prototype">module coap.observe_read_stream.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.observe_read_stream.prototype._read">
            function <span class="apidocSignatureSpan">coap.observe_read_stream.prototype.</span>_read
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.observe_read_stream.prototype.append">
            function <span class="apidocSignatureSpan">coap.observe_read_stream.prototype.</span>append
            <span class="apidocSignatureSpan">(packet)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.observe_read_stream.prototype.close">
            function <span class="apidocSignatureSpan">coap.observe_read_stream.prototype.</span>close
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.coap.observe_write_stream">module coap.observe_write_stream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.observe_write_stream.observe_write_stream">
            function <span class="apidocSignatureSpan">coap.</span>observe_write_stream
            <span class="apidocSignatureSpan">(request, send)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.observe_write_stream.super_">
            function <span class="apidocSignatureSpan">coap.observe_write_stream.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.coap.observe_write_stream.prototype">module coap.observe_write_stream.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.observe_write_stream.prototype._doSend">
            function <span class="apidocSignatureSpan">coap.observe_write_stream.prototype.</span>_doSend
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.observe_write_stream.prototype._write">
            function <span class="apidocSignatureSpan">coap.observe_write_stream.prototype.</span>_write
            <span class="apidocSignatureSpan">(data, encoding, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.observe_write_stream.prototype.reset">
            function <span class="apidocSignatureSpan">coap.observe_write_stream.prototype.</span>reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.observe_write_stream.prototype.setHeader">
            function <span class="apidocSignatureSpan">coap.observe_write_stream.prototype.</span>setHeader
            <span class="apidocSignatureSpan">(name, values)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.observe_write_stream.prototype.setOption">
            function <span class="apidocSignatureSpan">coap.observe_write_stream.prototype.</span>setOption
            <span class="apidocSignatureSpan">(name, values)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.coap.option_converter">module coap.option_converter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.option_converter.fromBinary">
            function <span class="apidocSignatureSpan">coap.option_converter.</span>fromBinary
            <span class="apidocSignatureSpan">(name, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.option_converter.ignoreOption">
            function <span class="apidocSignatureSpan">coap.option_converter.</span>ignoreOption
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.option_converter.isIgnored">
            function <span class="apidocSignatureSpan">coap.option_converter.</span>isIgnored
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.option_converter.registerFormat">
            function <span class="apidocSignatureSpan">coap.option_converter.</span>registerFormat
            <span class="apidocSignatureSpan">(name, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.option_converter.registerOption">
            function <span class="apidocSignatureSpan">coap.option_converter.</span>registerOption
            <span class="apidocSignatureSpan">(name, toBinary, fromBinary)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.option_converter.toBinary">
            function <span class="apidocSignatureSpan">coap.option_converter.</span>toBinary
            <span class="apidocSignatureSpan">(name, value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.coap.outgoing_message">module coap.outgoing_message</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.outgoing_message.outgoing_message">
            function <span class="apidocSignatureSpan">coap.</span>outgoing_message
            <span class="apidocSignatureSpan">(request, send)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.outgoing_message.super_">
            function <span class="apidocSignatureSpan">coap.outgoing_message.</span>super_
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.coap.outgoing_message.prototype">module coap.outgoing_message.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.outgoing_message.prototype.end">
            function <span class="apidocSignatureSpan">coap.outgoing_message.prototype.</span>end
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.outgoing_message.prototype.reset">
            function <span class="apidocSignatureSpan">coap.outgoing_message.prototype.</span>reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.outgoing_message.prototype.setHeader">
            function <span class="apidocSignatureSpan">coap.outgoing_message.prototype.</span>setHeader
            <span class="apidocSignatureSpan">(name, values)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.outgoing_message.prototype.setOption">
            function <span class="apidocSignatureSpan">coap.outgoing_message.prototype.</span>setOption
            <span class="apidocSignatureSpan">(name, values)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.outgoing_message.prototype.writeHead">
            function <span class="apidocSignatureSpan">coap.outgoing_message.prototype.</span>writeHead
            <span class="apidocSignatureSpan">(code, headers)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.coap.parameters">module coap.parameters</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">coap.parameters.</span>sendAcksForNonConfirmablePackets</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.parameters.defaultTiming">
            function <span class="apidocSignatureSpan">coap.parameters.</span>defaultTiming
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.parameters.refreshTiming">
            function <span class="apidocSignatureSpan">coap.parameters.</span>refreshTiming
            <span class="apidocSignatureSpan">(values)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">coap.parameters.</span>ackRandomFactor</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">coap.parameters.</span>ackTimeout</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">coap.parameters.</span>coapPort</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">coap.parameters.</span>exchangeLifetime</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">coap.parameters.</span>maxLatency</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">coap.parameters.</span>maxPacketSize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">coap.parameters.</span>maxRTT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">coap.parameters.</span>maxRetransmit</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">coap.parameters.</span>maxTransmitSpan</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">coap.parameters.</span>maxTransmitWait</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">coap.parameters.</span>piggybackReplyMs</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">coap.parameters.</span>processingDelay</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">coap.parameters.</span>pruneTimerPeriod</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.coap.polyfill">module coap.polyfill</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.polyfill.compareBuffers">
            function <span class="apidocSignatureSpan">coap.polyfill.</span>compareBuffers
            <span class="apidocSignatureSpan">(buf1, buf2)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.coap.registerFormat">module coap.registerFormat</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.registerFormat.registerFormat">
            function <span class="apidocSignatureSpan">coap.</span>registerFormat
            <span class="apidocSignatureSpan">(name, value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.coap.registerOption">module coap.registerOption</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.registerOption.registerOption">
            function <span class="apidocSignatureSpan">coap.</span>registerOption
            <span class="apidocSignatureSpan">(name, toBinary, fromBinary)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.coap.request">module coap.request</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.request.request">
            function <span class="apidocSignatureSpan">coap.</span>request
            <span class="apidocSignatureSpan">(url)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.coap.retry_send">module coap.retry_send</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.retry_send.retry_send">
            function <span class="apidocSignatureSpan">coap.</span>retry_send
            <span class="apidocSignatureSpan">(sock, port, host)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.retry_send.super_">
            function <span class="apidocSignatureSpan">coap.retry_send.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.coap.retry_send.prototype">module coap.retry_send.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.retry_send.prototype._send">
            function <span class="apidocSignatureSpan">coap.retry_send.prototype.</span>_send
            <span class="apidocSignatureSpan">(avoidBackoff)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.retry_send.prototype.reset">
            function <span class="apidocSignatureSpan">coap.retry_send.prototype.</span>reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.retry_send.prototype.send">
            function <span class="apidocSignatureSpan">coap.retry_send.prototype.</span>send
            <span class="apidocSignatureSpan">(message, avoidBackoff)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.coap.updateTiming">module coap.updateTiming</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.coap.updateTiming.updateTiming">
            function <span class="apidocSignatureSpan">coap.</span>updateTiming
            <span class="apidocSignatureSpan">(values)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.coap" id="apidoc.module.coap">module coap</a></h1>


    <h2>
        <a href="#apidoc.element.coap.Agent" id="apidoc.element.coap.Agent">
        function <span class="apidocSignatureSpan">coap.</span>Agent
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Agent(opts) {
  if (!(this instanceof Agent))
    return new Agent()

  if (!opts)
    opts = {}

  if (!opts.type)
    opts.type = &#x27;udp4&#x27;

  if (opts.socket) {
    delete opts.port
  }

  this._opts = opts

  this._init(opts.socket)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
registerFormat(&#x27;application/octet-stream&#x27;, 42)
registerFormat(&#x27;application/exi&#x27;, 47)
registerFormat(&#x27;application/json&#x27;, 50)
```

-------------------------------------------------------
&#x3c;a name=&#x22;agent&#x22;&#x3e;&#x3c;/a&#x3e;
### coap.<span class="apidocCodeKeywordSpan">Agent</span>([opts])

An Agent encapsulate an UDP Socket. It uses a combination of `messageId`
and `token` to distinguish between the different exchanges.
The socket will auto-close itself when no more exchange are in place.

By default, no UDP socket are open, and it is opened on demand to send
the messages.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.Agent.prototype._cleanUp" id="apidoc.element.coap.Agent.prototype._cleanUp">
        function <span class="apidocSignatureSpan">coap.</span>Agent.prototype._cleanUp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cleanUp() {
  if (--this._requests !== 0)
    return

  this._closing = true

  if (this._msgInFlight !== 0)
    return

  this._doClose()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.Agent.prototype._doClose" id="apidoc.element.coap.Agent.prototype._doClose">
        function <span class="apidocSignatureSpan">coap.</span>Agent.prototype._doClose
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Agent.prototype._doClose = function () {
  for (var k in this._msgIdToReq)
    this._msgIdToReq[k].sender.reset()

  if (this._opts.socket)
    return

  this._sock.close()
  this._sock = null
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.Agent.prototype._handle" id="apidoc.element.coap.Agent.prototype._handle">
        function <span class="apidocSignatureSpan">coap.</span>Agent.prototype._handle
        <span class="apidocSignatureSpan">(msg, rsinfo, outSocket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function handle(msg, rsinfo, outSocket) {
  var packet = parse(msg)
    , buf
    , response
    , that = this
    , req = this._msgIdToReq[packet.messageId]
    , ackSent = function(err) {
        if (err &#x26;&#x26; req)
          req.emit(&#x27;error&#x27;, err)

        that._msgInFlight--
        if (that._closing &#x26;&#x26; that._msgInFlight === 0) {
          that._doClose()
        }
      }

  if (!req) {
    if (packet.token.length == 4) {
      req = this._tkToReq[packet.token.readUInt32BE(0)]
    }

    if (packet.ack &#x26;&#x26; !req) {
      // nothing to do, somehow there was
      // a duplicate ack
      return
    }

    if (!req) {
      buf = generate({
          code: &#x27;0.00&#x27;
        , reset: true
        , messageId: packet.messageId
      })

      this._msgInFlight++
      this._sock.send(buf, 0, buf.length, rsinfo.port, rsinfo.address, ackSent)
      return
    }
  }

  if (packet.confirmable) {
    buf = generate({
        code: &#x27;0.00&#x27;
      , ack: true
      , messageId: packet.messageId
    })

    this._msgInFlight++
    this._sock.send(buf, 0, buf.length, rsinfo.port, rsinfo.address, ackSent)
  }

  if (packet.code != &#x27;0.00&#x27; &#x26;&#x26; (req._packet.token.length != packet.token.length || pf.compareBuffers(req._packet.token, packet.token
) != 0)) {
    // The tokens don&#x27;t match, ignore the message since it is a malformed response
    return
  }

  if (!packet.confirmable &#x26;&#x26; !req.multicast) {
    delete this._msgIdToReq[packet.messageId]
  }

  req.sender.reset()

  if (packet.code == &#x27;0.00&#x27;)
    return

  var block2Buff = getOption(packet.options, &#x27;Block2&#x27;)
  var block2
  // if we got blockwise (2) response
  if (block2Buff) {
    block2 = parseBlock2(block2Buff)
    // check for error
    if (!block2) {
      req.sender.reset()
      return req.emit(&#x27;error&#x27;, new Error(&#x27;failed to parse block2&#x27;))
    }
  }
  if (block2) {
    // accumulate payload
    req._totalPayload = Buffer.concat([req._totalPayload, packet.payload])

    if (block2.moreBlock2) {
      // increase message id for next request
      delete this._msgIdToReq[req._packet.messageId]
      req._packet.messageId = that._nextMessageId()
      this._msgIdToReq[req._packet.messageId] = req

      // next block2 request
      var block2Val = createBlock2({
        moreBlock2: false,
        num: block2.num+1,
        size: block2.size
      })
      if (!block2Val) {
        req.sender.reset()
        return req.emit(&#x27;error&#x27;, new Error(&#x27;failed to create block2&#x27;))
      }
      req.setOption(&#x27;Block2&#x27;, block2Val)
      req.sender.send(generate(req._packet))

      return
    }
    else {
      // get full payload
      packet.payload = req._totalPayload
      // clear the payload incase of block2
      req._totalPayload = new Buffer(0)
    }
  }

  if (req.response) {
    if (req.response.append) {
      // it is an observe request
      // and we are already streaming
      return req.response.append(packet)
    } else {
      // TODO There is a previous response but is not an ObserveStream !
      return
    }

  }
  else if (block2) {
    delete that._tkToReq[req._packet.token.readUInt32BE(0)]
  }
  else if (!req.url.observe &#x26;&#x26; packet.token.length &#x3e; 0) {
    // it is not, so delete the token
    delete that._tkToReq[packet.token.readUInt32BE(0)]
  }

  if (req.url.observe &#x26;&#x26; packet.code !== &#x27;4.04&#x27;) {
    response = new ObserveStream(packet, rsinfo, outSocket)
    response.on(&#x27;close&#x27;, function() {
      delete that._tkToReq[packet.token.readUInt32BE(0)]
      that._cleanUp()
    })
  } else {
    response = new IncomingMessage(packet, rsinfo, outSocket)
  }

  if (!req.multicast) {
    req.response = response
  }

  req.emit(&#x27;response&#x27;, response)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.Agent.prototype._init" id="apidoc.element.coap.Agent.prototype._init">
        function <span class="apidocSignatureSpan">coap.</span>Agent.prototype._init
        <span class="apidocSignatureSpan">(socket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function initSock(socket) {
  if (this._sock) {
    return
  }

  var that = this
  this._sock = socket || dgram.createSocket(this._opts.type)
  this._sock.on(&#x27;message&#x27;, function(msg, rsinfo) {
    var packet
      , message
      , outSocket

    try {
      packet = parse(msg)
    } catch(err) {
      message = generate({ code: &#x27;5.00&#x27;, payload: new Buffer(&#x27;Unable to parse packet&#x27;) })
      that._sock.send(message, 0, message.length,
                      rsinfo.port, rsinfo.address)
      return
    }

    if (packet.code[0] === &#x27;0&#x27; &#x26;&#x26; packet.code !== &#x27;0.00&#x27;) {
      // ignore this packet since it&#x27;s not a response.
      return
    }

    outSocket = that._sock.address();
    that._handle(msg, rsinfo, outSocket)
  })

  if(this._opts.port){
    this._sock.bind( this._opts.port );
  };

  this._sock.on(&#x27;error&#x27;, function(err) {
    // we are skipping DNS errors
    if(!hasDNSbug || err.code !== &#x27;ENOTFOUND&#x27;)
      that.emit(&#x27;error&#x27;, err)
  })

  this._msgIdToReq = {}
  this._tkToReq = {}

  this._lastToken = Math.floor(Math.random() * (maxToken - 1))
  this._lastMessageId = Math.floor(Math.random() * (maxMessageId - 1))

  this._closing = false
  this._msgInFlight = 0
  this._requests = 0
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.Agent.prototype._nextMessageId" id="apidoc.element.coap.Agent.prototype._nextMessageId">
        function <span class="apidocSignatureSpan">coap.</span>Agent.prototype._nextMessageId
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nextToken() {
  if (++this._lastMessageId === maxMessageId)
    this._lastMessageId = 1

  return this._lastMessageId
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.Agent.prototype._nextToken" id="apidoc.element.coap.Agent.prototype._nextToken">
        function <span class="apidocSignatureSpan">coap.</span>Agent.prototype._nextToken
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nextToken() {
  var buf = new Buffer(4)

  if (++this._lastToken === maxToken)
    this._lastToken = 0

  buf.writeUInt32BE(this._lastToken, 0)

  return buf;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.Agent.prototype.abort" id="apidoc.element.coap.Agent.prototype.abort">
        function <span class="apidocSignatureSpan">coap.</span>Agent.prototype.abort
        <span class="apidocSignatureSpan">(req)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Agent.prototype.abort = function (req) {
  req.sender.removeAllListeners()
  req.sender.reset()
  this._cleanUp()
  delete this._msgIdToReq[req._packet.messageId]
  delete this._tkToReq[req._packet.token.readUInt32BE(0)]
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.Agent.prototype.request" id="apidoc.element.coap.Agent.prototype.request">
        function <span class="apidocSignatureSpan">coap.</span>Agent.prototype.request
        <span class="apidocSignatureSpan">(url)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function request(url) {
  this._init()

  var req
    , response
    , options = url.options || url.headers
    , option
    , that = this
    , multicastTimeout = url.multicastTimeout !== undefined ? parseInt(url.multicastTimeout) : 20000

  req = new OutgoingMessage({}, function(req, packet) {
    var buf

    if (url.confirmable !== false) {
      packet.confirmable = true
    }

    // multicast message should be forced non-confirmable
    if (url.multicast === true) {
      req.multicast = true
      packet.confirmable = false
    }

    if (!(packet.ack || packet.reset)) {
      packet.messageId = that._nextMessageId()
      packet.token = that._nextToken()
    }

    try {
      buf = generate(packet)
    } catch(err) {
      req.sender.reset()
      return req.emit(&#x27;error&#x27;, err)
    }

    that._msgIdToReq[packet.messageId] = req
    that._tkToReq[that._lastToken] = req

    req.sender.send(buf, !packet.confirmable)
  })

  req.sender = new RetrySend(this._sock, url.port, url.hostname || url.host)

  req.url = url

  req.statusCode = url.method || &#x27;GET&#x27;

  urlPropertyToPacketOption(url, req, &#x27;pathname&#x27;, &#x27;Uri-Path&#x27;, &#x27;/&#x27;)
  urlPropertyToPacketOption(url, req, &#x27;query&#x27;, &#x27;Uri-Query&#x27;, &#x27;&#x26;&#x27;)

  if (options) {
    for (option in options) {
      if (options.hasOwnProperty(option)) {
        req.setOption(option, options[option])
      }
    }
  }

  if (url.proxyUri) {
    req.setOption(&#x27;Proxy-Uri&#x27;, url.proxyUri)
  }

  req.sender.on(&#x27;error&#x27;, req.emit.bind(req, &#x27;error&#x27;))

  req.sender.on(&#x27;sending&#x27;, function() {
    that._msgInFlight++
  })

  req.sender.on(&#x27;timeout&#x27;, function (err) {
    req.emit(&#x27;timeout&#x27;, err)
    that.abort(req)
  })

  req.sender.on(&#x27;sent&#x27;, function() {
    if (req.multicast) return;

    that._msgInFlight--
    if (that._closing &#x26;&#x26; that._msgInFlight === 0) {
      that._doClose()
    }
  })

  // Start multicast monitoring timer in case of multicast request
  if (url.multicast === true) {
    req.multicastTimer = setTimeout(function() {
      that._msgInFlight--
      if (that._msgInFlight === 0) {
        that._doClose()
      }
    }, multicastTimeout)
  }

  if (url.observe)
    req.setOption(&#x27;Observe&#x27;, null)
  else
    req.on(&#x27;response&#x27;, this._cleanUp.bind(this))

  this._requests++

  req._totalPayload = new Buffer(0)

  return req
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.createServer" id="apidoc.element.coap.createServer">
        function <span class="apidocSignatureSpan">coap.</span>createServer
        <span class="apidocSignatureSpan">(options, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CoAPServer(options, listener) {
  if (!(this instanceof CoAPServer)) {
    return new CoAPServer(options, listener)
  }

  if (typeof options === &#x27;function&#x27;) {
    listener = options
    options = null
  }

  if (!options)
    options = {}

  this._options = options
  this._proxiedRequests = {}

  this._middlewares = [
    middlewares.parseRequest
  ]

  if (options.proxy) {
    this._middlewares.push(middlewares.proxyRequest)
    this._middlewares.push(middlewares.handleProxyResponse)
  }

  if (!this._options.piggybackReplyMs || !isNumeric(this._options.piggybackReplyMs)) {
    this._options.piggybackReplyMs = parameters.piggybackReplyMs
  }

  if (!isBoolean(this._options.sendAcksForNonConfirmablePackets)) {
    this._options.sendAcksForNonConfirmablePackets = parameters.sendAcksForNonConfirmablePackets
  }
  this._middlewares.push(middlewares.handleServerRequest)

  // Multicast settings
  this._multicastAddress = options.multicastAddress ? options.multicastAddress : null
  this._multicastInterface = options.multicastInterface ? options.multicastInterface : null

  // We use an LRU cache for the responses to avoid
  // DDOS problems.
  // max packet size is 1280
  // 32 MB / 1280 = 26214
  // The max lifetime is roughly 200s per packet.
  // Which gave us 131 packets/second guarantee
  this._lru = LRU({
      max: options.cacheSize || (32768 * 1024)
    , length: function(n) { return n.buffer.byteLength }
    , maxAge: (parameters.exchangeLifetime * 1000)
    , dispose:  function(key, value) {
                  if (value.sender)
                    value.sender.reset()
                }
  })

  this._series = series()
  this._block2Cache = {}

  if (listener)
    this.on(&#x27;request&#x27;, listener)
  debug(&#x27;initialized&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
## Basic Example

The following example opens a UDP server and sends a
CoAP message to it:

```js
var coap        = require(&#x27;coap&#x27;)
  , server      = coap.<span class="apidocCodeKeywordSpan">createServer</span>()

server.on(&#x27;request&#x27;, function(req, res) {
  res.end(&#x27;Hello &#x27; + req.url.split(&#x27;/&#x27;)[1] + &#x27;\n&#x27;)
})

// the default CoAP port is 5683
server.listen(function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.createServer.prototype._handle" id="apidoc.element.coap.createServer.prototype._handle">
        function <span class="apidocSignatureSpan">coap.</span>createServer.prototype._handle
        <span class="apidocSignatureSpan">(packet, rsinfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createServer.prototype._handle = function (packet, rsinfo) {

  if (packet.code[0] !== &#x27;0&#x27;) {
    // According to RFC7252 Section 4.2 receiving a confirmable messages
    // that can&#x27;t be processed, should be rejected by ignoring it AND
    // sending a reset. In this case confirmable response message would
    // be silently ignored, which is not exactly as stated in the standard.
    // However, sending a reset would interfere with a coap client which is
    // re-using a socket (see pull-request #131).
    return
  }

  var sock      = this._sock
    , lru       = this._lru
    , acks      = this._acks
    , cached    = lru.peek(toKey(rsinfo.address, rsinfo.port, packet, true))
    , Message   = OutMessage
    , that = this
    , request
    , response

  if (cached &#x26;&#x26; !packet.ack &#x26;&#x26; !packet.reset) {
    return sock.send(cached, 0, cached.length, rsinfo.port, rsinfo.address)
  } else if (cached &#x26;&#x26; (packet.ack || packet.reset)) {
    if (cached.response &#x26;&#x26; packet.reset) {
      cached.response.end()
    }
    return lru.del(toKey(rsinfo.address, rsinfo.port, packet, false))
  }
  else if (packet.ack || packet.reset) {
    return // nothing to do, ignoring silently
  }

  request = new IncomingMessage(packet, rsinfo)

  if (request.headers[&#x27;Observe&#x27;] === 0) {
    Message = ObserveStream
    if (packet.code !== &#x27;0.01&#x27;)
      // it is not a GET
      return this._sendError(new Buffer(&#x27;Observe can only be present with a GET&#x27;), rsinfo)
  }

  packet.piggybackReplyMs = this._options.piggybackReplyMs;
  response = new Message(packet, function(response, packet) {
    var buf
      , sender = new RetrySend(sock, rsinfo.port, rsinfo.address)

    try {
      buf = generate(packet)
    } catch(err) {
      return response.emit(&#x27;error&#x27;, err)
    }

    if (Message === OutMessage) {
      sender.on(&#x27;error&#x27;, response.emit.bind(response, &#x27;error&#x27;))
    } else {
      buf.response = response
      sender.on(&#x27;error&#x27;, function() {
        response.end()
      })
    }

    var key = toKey(rsinfo.address, rsinfo.port,
        packet, packet.ack || !packet.confirmable)
    lru.set(key, buf)
    buf.sender = sender

    if (that._options.sendAcksForNonConfirmablePackets || packet.confirmable){
      sender.send(buf, packet.ack || packet.reset || packet.confirmable === false)
    } else {
      debug(&#x27;OMIT ACK PACKAGE&#x27;)
    }
  })

  request.rsinfo = rsinfo
  response.statusCode = &#x27;2.05&#x27;
  response._request = request._packet
  response._cachekey = toCacheKey(rsinfo.address, rsinfo.port, packet)

  var block2cache = this._block2Cache
  //inject this function so the response can add an entry to the cache
  response._addCacheEntry = function(key, payload) {
    if (block2cache.hasOwnProperty(key)) {
      debug(&#x27;reuse old cache entry, key:&#x27;, key)
      clearTimeout(block2cache[key].timeoutId) // cancel old expiry timer
      block2cache[key].payload = payload
    } else {
      debug(&#x27;add payload to cache, key:&#x27;, key)
      block2cache[key] = {payload: payload}
    }
    // setup new expiry timer
    block2cache[key].timeoutId = setTimeout(expiry, parameters.exchangeLifetime * 1000, block2cache, key)
  }

  //return cached value for blockwise requests
  var cachedResponseSend = false
  if (packet.token &#x26;&#x26; packet.token.length &#x3e; 0) {
    // return cached value only if this request is not the first block request
    var block2Buff = getOption(response._request.options, &#x27;Block2&#x27;)
    var requestedBlockOption
    if (block2Buff) {
      requestedBlockOption = parseBlock2(block2Buff)
    }
    if (!requestedBlockOption) {
      requestedBlockOption = {num: 0}
    }

    if (requestedBlockOption.num &#x3c; 1) {
      if (this._block2Cache.hasOwnProperty(response._cachekey)) {
        debug(&#x27;first block2 request, remove old entry from cache, key:&#x27;, response._cachekey)
        clearTimeout(this._block2Cache[response._cachekey].timeoutId)
        delete this._block2Cache[response._cachekey]
      }
    } else {
      debug(&#x27;check if packet token is in cache, key:&#x27;, response._cachekey)
      if (this._block2Cache.hasOwnProperty(response._cachekey)) {
        debug(&#x27;found cached payload, key:&#x27; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.createServer.prototype._sendError" id="apidoc.element.coap.createServer.prototype._sendError">
        function <span class="apidocSignatureSpan">coap.</span>createServer.prototype._sendError
        <span class="apidocSignatureSpan">(payload, rsinfo, packet)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createServer.prototype._sendError = function (payload, rsinfo, packet) {
  var message = generate({
    code: &#x27;5.00&#x27;,
    payload: payload,
    messageId: (packet)?packet.messageId:undefined,
    token: (packet)?packet.token:undefined
  })

  this._sock.send(message, 0, message.length, rsinfo.port)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.createServer.prototype._sendProxied" id="apidoc.element.coap.createServer.prototype._sendProxied">
        function <span class="apidocSignatureSpan">coap.</span>createServer.prototype._sendProxied
        <span class="apidocSignatureSpan">(packet, proxyUri, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createServer.prototype._sendProxied = function (packet, proxyUri, callback) {
  var url = require(&#x27;url&#x27;).parse(proxyUri)
    , host = url.hostname
    , port = url.port
    , message = generate(removeProxyOptions(packet))

  this._sock.send(message, 0, message.length, port, host, callback)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.createServer.prototype._sendReverseProxied" id="apidoc.element.coap.createServer.prototype._sendReverseProxied">
        function <span class="apidocSignatureSpan">coap.</span>createServer.prototype._sendReverseProxied
        <span class="apidocSignatureSpan">(packet, rsinfo, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createServer.prototype._sendReverseProxied = function (packet, rsinfo, callback) {
  var host = rsinfo.address
    , port = rsinfo.port
    , message = generate(packet)

  this._sock.send(message, 0, message.length, port, host, callback)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.createServer.prototype.close" id="apidoc.element.coap.createServer.prototype.close">
        function <span class="apidocSignatureSpan">coap.</span>createServer.prototype.close
        <span class="apidocSignatureSpan">(done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createServer.prototype.close = function (done) {
  if (done) {
    setImmediate(done)
  }

  if (this._lru.pruneTimer) {
    clearInterval(this._lru.pruneTimer)
  }

  if (this._sock) {
    this._sock.close()
    this._lru.reset()
    this._sock = null
    this.emit(&#x27;close&#x27;)
  } else {
    this._lru.reset()
  }

  // cancel cache entry expiry timers
  for (var k in this._block2Cache) {
    if (this._block2Cache.hasOwnProperty(k)) {
      debug(&#x27;clean-up cache expiry timer, key:&#x27;, k)
      clearTimeout(this._block2Cache[k].timeoutId)
      delete this._block2Cache[k]
    }
  }

  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.createServer.prototype.listen" id="apidoc.element.coap.createServer.prototype.listen">
        function <span class="apidocSignatureSpan">coap.</span>createServer.prototype.listen
        <span class="apidocSignatureSpan">(port, address, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createServer.prototype.listen = function (port, address, done) {
  var that = this

  if (port == undefined) {
    port = parameters.coapPort
  }

  if (typeof port === &#x27;function&#x27;) {
    done = port
    port = parameters.coapPort
  }

  if (typeof address === &#x27;function&#x27;) {
    done = address
    address = null
  }

  if (this._sock) {
    if (done)
      done(new Error(&#x27;Already listening&#x27;))
    else
      throw new Error(&#x27;Already listening&#x27;)

    return this
  }

  if (address &#x26;&#x26; net.isIPv6(address))
    this._options.type = &#x27;udp6&#x27;

  if (!this._options.type)
    this._options.type = &#x27;udp4&#x27;

  this._sock = dgram.createSocket({type: this._options.type, reuseAddr : true}, handleRequest(this))

  this._sock.on(&#x27;error&#x27;, function(error) {
    that.emit(&#x27;error&#x27;, error)
  })

  this._sock.bind(port, address || null, function () {
    if (that._multicastAddress) {
      that._sock.setMulticastLoopback(true)

      if (that._multicastInterface) {
        that._sock.addMembership(that._multicastAddress, that._multicastInterface)
      } else {
        allAddresses(that._options.type).forEach(function(interface) {
            that._sock.addMembership(that._multicastAddress, interface)
        })
      }
    }
    if (done) done()
  })
  this._port = port
  this._address = address

  if (parameters.pruneTimerPeriod) {
    // Start LRU pruning timer
    this._lru.pruneTimer = setInterval(function () {
      that._lru.prune()
    }, parameters.pruneTimerPeriod*1000)
    if (this._lru.pruneTimer.unref) {
      this._lru.pruneTimer.unref()
    }
  }

  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.defaultTiming" id="apidoc.element.coap.defaultTiming">
        function <span class="apidocSignatureSpan">coap.</span>defaultTiming
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaultTiming = function () {
  p.refreshTiming(defaultTiming)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.ignoreOption" id="apidoc.element.coap.ignoreOption">
        function <span class="apidocSignatureSpan">coap.</span>ignoreOption
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ignoreOption = function (name) {
  ignoredOptions[name] = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Register a new option to be converted to string and added to the
`message.headers`.
`toBinary` is a function that accept a string and returns a `Buffer`.
`toString` is a function that accept a `Buffer` and returns a `String`.

-------------------------------------------------------
&#x3c;a name=&#x22;ignoreOption&#x22;&#x3e;&#x3c;/a&#x3e;
### coap.<span class="apidocCodeKeywordSpan">ignoreOption</span>(name)

Explicitly ignore an option; useful for compatibility with `http`-based
modules.

-------------------------------------------------------
&#x3c;a name=&#x22;registerFormat&#x22;&#x3e;&#x3c;/a&#x3e;
### coap.registerFormat(name, value)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.incoming_message" id="apidoc.element.coap.incoming_message">
        function <span class="apidocSignatureSpan">coap.</span>incoming_message
        <span class="apidocSignatureSpan">(packet, rsinfo, outSocket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function IncomingMessage(packet, rsinfo, outSocket) {
  Readable.call(this)

  pktToMsg(this, packet)

  this.rsinfo = rsinfo
  this.outSocket = outSocket

  this._packet = packet
  this._payloadIndex = 0
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.observe_read_stream" id="apidoc.element.coap.observe_read_stream">
        function <span class="apidocSignatureSpan">coap.</span>observe_read_stream
        <span class="apidocSignatureSpan">(packet, rsinfo, outSocket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ObserveReadStream(packet, rsinfo, outSocket) {
  Readable.call(this, { objectMode: true })

  this.rsinfo = rsinfo
  this.outSocket = outSocket

  this._lastId = 0
  this.append(packet)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.observe_write_stream" id="apidoc.element.coap.observe_write_stream">
        function <span class="apidocSignatureSpan">coap.</span>observe_write_stream
        <span class="apidocSignatureSpan">(request, send)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ObserveWriteStream(request, send) {
  Writable.call(this)

  this._packet = {
      token: request.token
    , messageId: request.messageId
    , options: []
    , confirmable: false
    , ack: request.confirmable
    , reset: false
  }

  this._request = request
  this._send = send
  this.statusCode = &#x27;&#x27;

  this._counter = 0

  var that = this
  this.on(&#x27;finish&#x27;, function() {
    if (that._counter === 0) { // we have sent no messages
      that._doSend(null)
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.outgoing_message" id="apidoc.element.coap.outgoing_message">
        function <span class="apidocSignatureSpan">coap.</span>outgoing_message
        <span class="apidocSignatureSpan">(request, send)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function OutgoingMessage(request, send) {
  BufferList.call(this)

  this._packet = {
      messageId: request.messageId
    , token: request.token
    , options: []
    , confirmable: false
    , ack: false
    , reset: false
  }

  var that = this

  if (request.confirmable) {
    // replying in piggyback
    this._packet.ack = true

    this._ackTimer = setTimeout(function() {

      send(that, helpers.genAck(request))

      // we are no more in piggyback
      that._packet.confirmable = true
      that._packet.ack = false

      // we need a new messageId for the CON
      // reply
      delete that._packet.messageId

      that._ackTimer = null

    }, request.piggybackReplyMs)
  }

  this._send = send

  this.statusCode = &#x27;&#x27;
  this.code = &#x27;&#x27;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.registerFormat" id="apidoc.element.coap.registerFormat">
        function <span class="apidocSignatureSpan">coap.</span>registerFormat
        <span class="apidocSignatureSpan">(name, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerFormat = function (name, value) {
  var bytes;

  if (value &#x3e; 255) {
    bytes = new Buffer(2);
    bytes.writeUInt16BE(value, 0);
  } else {
    bytes = new Buffer([value])
  }

  formatsString[name] = bytes
  formatsBinaries[value] = name
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### coap.ignoreOption(name)

Explicitly ignore an option; useful for compatibility with `http`-based
modules.

-------------------------------------------------------
&#x3c;a name=&#x22;registerFormat&#x22;&#x3e;&#x3c;/a&#x3e;
### coap.<span class="apidocCodeKeywordSpan">registerFormat</span>(name, value)

Register a new format to be interpreted and sent in CoAP
`Content-Format` option.
Each format is identified by a number, see the [Content-Format
registry](http://tools.ietf.org/html/draft-ietf-core-coap-18#section-12.3).

These are the defaults formats:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.registerOption" id="apidoc.element.coap.registerOption">
        function <span class="apidocSignatureSpan">coap.</span>registerOption
        <span class="apidocSignatureSpan">(name, toBinary, fromBinary)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerOption = function (name, toBinary, fromBinary) {
  optionFromBinaryFunctions[name] = fromBinary
  optionToBinaryFunctions[name] = toBinary
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

#### reset()
Returns a Reset COAP Message to the sender. The RST message will appear as an empty message with code `0.00` and the
reset flag set to `true` to the caller. This action ends the interaction with the caller.

-------------------------------------------------------
&#x3c;a name=&#x22;registerOption&#x22;&#x3e;&#x3c;/a&#x3e;
### coap.<span class="apidocCodeKeywordSpan">registerOption</span>(name, toBinary, toString)

Register a new option to be converted to string and added to the
`message.headers`.
`toBinary` is a function that accept a string and returns a `Buffer`.
`toString` is a function that accept a `Buffer` and returns a `String`.

-------------------------------------------------------
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.request" id="apidoc.element.coap.request">
        function <span class="apidocSignatureSpan">coap.</span>request
        <span class="apidocSignatureSpan">(url)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">request = function (url) {
  var agent, req, ipv6

  if (typeof url === &#x27;string&#x27;)
    url = URL.parse(url)

  ipv6 = net.isIPv6(url.hostname || url.host)

  if (url.agent)
    agent = url.agent
  else if (url.agent === false &#x26;&#x26; !ipv6)
    agent = new Agent({ type: &#x27;udp4&#x27; })
  else if (url.agent === false &#x26;&#x26; ipv6)
    agent = new Agent({ type: &#x27;udp6&#x27; })
  else if (ipv6)
    agent = exports.globalAgentIPv6
  else
    agent = exports.globalAgent

  return agent.request(url)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

server.on(&#x27;request&#x27;, function(req, res) {
res.end(&#x27;Hello &#x27; + req.url.split(&#x27;/&#x27;)[1] + &#x27;\n&#x27;)
})

// the default CoAP port is 5683
server.listen(function() {
var req = coap.<span class="apidocCodeKeywordSpan">request</span>(&#x27;coap://localhost/Matteo&#x27;)

req.on(&#x27;response&#x27;, function(res) {
  res.pipe(process.stdout)
  res.on(&#x27;end&#x27;, function() {
    process.exit(0)
  })
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.retry_send" id="apidoc.element.coap.retry_send">
        function <span class="apidocSignatureSpan">coap.</span>retry_send
        <span class="apidocSignatureSpan">(sock, port, host)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RetrySend(sock, port, host) {
  if (!(this instanceof RetrySend))
    return new RetrySend(port, host)

  var that    = this

  this._sock  = sock

  this._port  = port || parameters.coapPort

  this._host  = host

  this._sendAttemp = 0
  this._lastMessageId = -1
  this._currentTime = parameters.ackTimeout * (1 + (parameters.ackRandomFactor - 1) * Math.random()) * 1000

  this._bOff  = function() {
    that._currentTime = that._currentTime * 2
    that._send()
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.updateTiming" id="apidoc.element.coap.updateTiming">
        function <span class="apidocSignatureSpan">coap.</span>updateTiming
        <span class="apidocSignatureSpan">(values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateTiming = function (values) {
  for (var key in values){
    if (p[key]) {
      p[key] = values[key]
    }
  }

  // MAX_TRANSMIT_SPAN is the maximum time from the first transmission
  // of a Confirmable message to its last retransmission.
  p.maxTransmitSpan = p.ackTimeout * ((Math.pow(2, p.maxRetransmit)) - 1) * p.ackRandomFactor

  // MAX_TRANSMIT_WAIT is the maximum time from the first transmission
  // of a Confirmable message to the time when the sender gives up on
  // receiving an acknowledgement or reset.
  p.maxTransmitWait = p.ackTimeout * (Math.pow(2, p.maxRetransmit + 1) - 1) * p.ackRandomFactor

  // PROCESSING_DELAY is the time a node takes to turn around a
  // Confirmable message into an acknowledgement.
  p.processingDelay = p.ackTimeout

  // MAX_RTT is the maximum round-trip time
  p.maxRTT = 2 * p.maxLatency + p.processingDelay

  //  EXCHANGE_LIFETIME is the time from starting to send a Confirmable
  //  message to the time when an acknowledgement is no longer expected,
  //  i.e.  message layer information about the message exchange can be
  //  purged
  p.exchangeLifetime = p.maxTransmitSpan + p.maxRTT

  // LRU prune timer period.
  // In order to reduce unnecessary heap usage on low-traffic servers the
  // LRU cache is periodically pruned to remove old, expired packets. This
  // is a fairly low-intensity task, but the period can be altered here
  // or the timer disabled by setting the value to zero.
  // By default the value is set to 0.5 x exchangeLifetime (~120s)
  if (values &#x26;&#x26; (typeof(values.pruneTimerPeriod)===&#x22;number&#x22;)) {
    p.pruneTimerPeriod = values.pruneTimerPeriod
  } else {
    p.pruneTimerPeriod =  (0.5 * p.exchangeLifetime)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var coapTiming = {
  ackTimeout:0.25,
  ackRandomFactor: 1.0,
  maxRetransmit: 3,
  maxLatency: 2,
  piggybackReplyMs: 10
};
coap.<span class="apidocCodeKeywordSpan">updateTiming</span>(coapTiming);
```

-------------------------------------------------------
&#x3c;a name=&#x22;defaultTiming&#x22;&#x3e;&#x3c;/a&#x3e;
### coap.defaultTiming

Reset the CoAP timings to the default values
...</pre></li>
    </ul>






























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.coap.Agent" id="apidoc.module.coap.Agent">module coap.Agent</a></h1>


    <h2>
        <a href="#apidoc.element.coap.Agent.Agent" id="apidoc.element.coap.Agent.Agent">
        function <span class="apidocSignatureSpan">coap.</span>Agent
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Agent(opts) {
  if (!(this instanceof Agent))
    return new Agent()

  if (!opts)
    opts = {}

  if (!opts.type)
    opts.type = &#x27;udp4&#x27;

  if (opts.socket) {
    delete opts.port
  }

  this._opts = opts

  this._init(opts.socket)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
registerFormat(&#x27;application/octet-stream&#x27;, 42)
registerFormat(&#x27;application/exi&#x27;, 47)
registerFormat(&#x27;application/json&#x27;, 50)
```

-------------------------------------------------------
&#x3c;a name=&#x22;agent&#x22;&#x3e;&#x3c;/a&#x3e;
### coap.<span class="apidocCodeKeywordSpan">Agent</span>([opts])

An Agent encapsulate an UDP Socket. It uses a combination of `messageId`
and `token` to distinguish between the different exchanges.
The socket will auto-close itself when no more exchange are in place.

By default, no UDP socket are open, and it is opened on demand to send
the messages.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.Agent.super_" id="apidoc.element.coap.Agent.super_">
        function <span class="apidocSignatureSpan">coap.Agent.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.coap.Agent.prototype" id="apidoc.module.coap.Agent.prototype">module coap.Agent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.coap.Agent.prototype._cleanUp" id="apidoc.element.coap.Agent.prototype._cleanUp">
        function <span class="apidocSignatureSpan">coap.Agent.prototype.</span>_cleanUp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cleanUp() {
  if (--this._requests !== 0)
    return

  this._closing = true

  if (this._msgInFlight !== 0)
    return

  this._doClose()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.Agent.prototype._doClose" id="apidoc.element.coap.Agent.prototype._doClose">
        function <span class="apidocSignatureSpan">coap.Agent.prototype.</span>_doClose
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_doClose = function () {
  for (var k in this._msgIdToReq)
    this._msgIdToReq[k].sender.reset()

  if (this._opts.socket)
    return

  this._sock.close()
  this._sock = null
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.Agent.prototype._handle" id="apidoc.element.coap.Agent.prototype._handle">
        function <span class="apidocSignatureSpan">coap.Agent.prototype.</span>_handle
        <span class="apidocSignatureSpan">(msg, rsinfo, outSocket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function handle(msg, rsinfo, outSocket) {
  var packet = parse(msg)
    , buf
    , response
    , that = this
    , req = this._msgIdToReq[packet.messageId]
    , ackSent = function(err) {
        if (err &#x26;&#x26; req)
          req.emit(&#x27;error&#x27;, err)

        that._msgInFlight--
        if (that._closing &#x26;&#x26; that._msgInFlight === 0) {
          that._doClose()
        }
      }

  if (!req) {
    if (packet.token.length == 4) {
      req = this._tkToReq[packet.token.readUInt32BE(0)]
    }

    if (packet.ack &#x26;&#x26; !req) {
      // nothing to do, somehow there was
      // a duplicate ack
      return
    }

    if (!req) {
      buf = generate({
          code: &#x27;0.00&#x27;
        , reset: true
        , messageId: packet.messageId
      })

      this._msgInFlight++
      this._sock.send(buf, 0, buf.length, rsinfo.port, rsinfo.address, ackSent)
      return
    }
  }

  if (packet.confirmable) {
    buf = generate({
        code: &#x27;0.00&#x27;
      , ack: true
      , messageId: packet.messageId
    })

    this._msgInFlight++
    this._sock.send(buf, 0, buf.length, rsinfo.port, rsinfo.address, ackSent)
  }

  if (packet.code != &#x27;0.00&#x27; &#x26;&#x26; (req._packet.token.length != packet.token.length || pf.compareBuffers(req._packet.token, packet.token
) != 0)) {
    // The tokens don&#x27;t match, ignore the message since it is a malformed response
    return
  }

  if (!packet.confirmable &#x26;&#x26; !req.multicast) {
    delete this._msgIdToReq[packet.messageId]
  }

  req.sender.reset()

  if (packet.code == &#x27;0.00&#x27;)
    return

  var block2Buff = getOption(packet.options, &#x27;Block2&#x27;)
  var block2
  // if we got blockwise (2) response
  if (block2Buff) {
    block2 = parseBlock2(block2Buff)
    // check for error
    if (!block2) {
      req.sender.reset()
      return req.emit(&#x27;error&#x27;, new Error(&#x27;failed to parse block2&#x27;))
    }
  }
  if (block2) {
    // accumulate payload
    req._totalPayload = Buffer.concat([req._totalPayload, packet.payload])

    if (block2.moreBlock2) {
      // increase message id for next request
      delete this._msgIdToReq[req._packet.messageId]
      req._packet.messageId = that._nextMessageId()
      this._msgIdToReq[req._packet.messageId] = req

      // next block2 request
      var block2Val = createBlock2({
        moreBlock2: false,
        num: block2.num+1,
        size: block2.size
      })
      if (!block2Val) {
        req.sender.reset()
        return req.emit(&#x27;error&#x27;, new Error(&#x27;failed to create block2&#x27;))
      }
      req.setOption(&#x27;Block2&#x27;, block2Val)
      req.sender.send(generate(req._packet))

      return
    }
    else {
      // get full payload
      packet.payload = req._totalPayload
      // clear the payload incase of block2
      req._totalPayload = new Buffer(0)
    }
  }

  if (req.response) {
    if (req.response.append) {
      // it is an observe request
      // and we are already streaming
      return req.response.append(packet)
    } else {
      // TODO There is a previous response but is not an ObserveStream !
      return
    }

  }
  else if (block2) {
    delete that._tkToReq[req._packet.token.readUInt32BE(0)]
  }
  else if (!req.url.observe &#x26;&#x26; packet.token.length &#x3e; 0) {
    // it is not, so delete the token
    delete that._tkToReq[packet.token.readUInt32BE(0)]
  }

  if (req.url.observe &#x26;&#x26; packet.code !== &#x27;4.04&#x27;) {
    response = new ObserveStream(packet, rsinfo, outSocket)
    response.on(&#x27;close&#x27;, function() {
      delete that._tkToReq[packet.token.readUInt32BE(0)]
      that._cleanUp()
    })
  } else {
    response = new IncomingMessage(packet, rsinfo, outSocket)
  }

  if (!req.multicast) {
    req.response = response
  }

  req.emit(&#x27;response&#x27;, response)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

function handleServerRequest(request, next) {
  if (request.proxy) {
    return next();
  }
  try {
    request.server.<span class="apidocCodeKeywordSpan">_handle</span>(request.packet, request.rsinfo)
    next(null)
  } catch (err) {
    next(err)
  }
}

function proxyRequest(request, next) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.Agent.prototype._init" id="apidoc.element.coap.Agent.prototype._init">
        function <span class="apidocSignatureSpan">coap.Agent.prototype.</span>_init
        <span class="apidocSignatureSpan">(socket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function initSock(socket) {
  if (this._sock) {
    return
  }

  var that = this
  this._sock = socket || dgram.createSocket(this._opts.type)
  this._sock.on(&#x27;message&#x27;, function(msg, rsinfo) {
    var packet
      , message
      , outSocket

    try {
      packet = parse(msg)
    } catch(err) {
      message = generate({ code: &#x27;5.00&#x27;, payload: new Buffer(&#x27;Unable to parse packet&#x27;) })
      that._sock.send(message, 0, message.length,
                      rsinfo.port, rsinfo.address)
      return
    }

    if (packet.code[0] === &#x27;0&#x27; &#x26;&#x26; packet.code !== &#x27;0.00&#x27;) {
      // ignore this packet since it&#x27;s not a response.
      return
    }

    outSocket = that._sock.address();
    that._handle(msg, rsinfo, outSocket)
  })

  if(this._opts.port){
    this._sock.bind( this._opts.port );
  };

  this._sock.on(&#x27;error&#x27;, function(err) {
    // we are skipping DNS errors
    if(!hasDNSbug || err.code !== &#x27;ENOTFOUND&#x27;)
      that.emit(&#x27;error&#x27;, err)
  })

  this._msgIdToReq = {}
  this._tkToReq = {}

  this._lastToken = Math.floor(Math.random() * (maxToken - 1))
  this._lastMessageId = Math.floor(Math.random() * (maxMessageId - 1))

  this._closing = false
  this._msgInFlight = 0
  this._requests = 0
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.Agent.prototype._nextMessageId" id="apidoc.element.coap.Agent.prototype._nextMessageId">
        function <span class="apidocSignatureSpan">coap.Agent.prototype.</span>_nextMessageId
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nextToken() {
  if (++this._lastMessageId === maxMessageId)
    this._lastMessageId = 1

  return this._lastMessageId
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.Agent.prototype._nextToken" id="apidoc.element.coap.Agent.prototype._nextToken">
        function <span class="apidocSignatureSpan">coap.Agent.prototype.</span>_nextToken
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nextToken() {
  var buf = new Buffer(4)

  if (++this._lastToken === maxToken)
    this._lastToken = 0

  buf.writeUInt32BE(this._lastToken, 0)

  return buf;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.Agent.prototype.abort" id="apidoc.element.coap.Agent.prototype.abort">
        function <span class="apidocSignatureSpan">coap.Agent.prototype.</span>abort
        <span class="apidocSignatureSpan">(req)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">abort = function (req) {
  req.sender.removeAllListeners()
  req.sender.reset()
  this._cleanUp()
  delete this._msgIdToReq[req._packet.messageId]
  delete this._tkToReq[req._packet.token.readUInt32BE(0)]
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.Agent.prototype.request" id="apidoc.element.coap.Agent.prototype.request">
        function <span class="apidocSignatureSpan">coap.Agent.prototype.</span>request
        <span class="apidocSignatureSpan">(url)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function request(url) {
  this._init()

  var req
    , response
    , options = url.options || url.headers
    , option
    , that = this
    , multicastTimeout = url.multicastTimeout !== undefined ? parseInt(url.multicastTimeout) : 20000

  req = new OutgoingMessage({}, function(req, packet) {
    var buf

    if (url.confirmable !== false) {
      packet.confirmable = true
    }

    // multicast message should be forced non-confirmable
    if (url.multicast === true) {
      req.multicast = true
      packet.confirmable = false
    }

    if (!(packet.ack || packet.reset)) {
      packet.messageId = that._nextMessageId()
      packet.token = that._nextToken()
    }

    try {
      buf = generate(packet)
    } catch(err) {
      req.sender.reset()
      return req.emit(&#x27;error&#x27;, err)
    }

    that._msgIdToReq[packet.messageId] = req
    that._tkToReq[that._lastToken] = req

    req.sender.send(buf, !packet.confirmable)
  })

  req.sender = new RetrySend(this._sock, url.port, url.hostname || url.host)

  req.url = url

  req.statusCode = url.method || &#x27;GET&#x27;

  urlPropertyToPacketOption(url, req, &#x27;pathname&#x27;, &#x27;Uri-Path&#x27;, &#x27;/&#x27;)
  urlPropertyToPacketOption(url, req, &#x27;query&#x27;, &#x27;Uri-Query&#x27;, &#x27;&#x26;&#x27;)

  if (options) {
    for (option in options) {
      if (options.hasOwnProperty(option)) {
        req.setOption(option, options[option])
      }
    }
  }

  if (url.proxyUri) {
    req.setOption(&#x27;Proxy-Uri&#x27;, url.proxyUri)
  }

  req.sender.on(&#x27;error&#x27;, req.emit.bind(req, &#x27;error&#x27;))

  req.sender.on(&#x27;sending&#x27;, function() {
    that._msgInFlight++
  })

  req.sender.on(&#x27;timeout&#x27;, function (err) {
    req.emit(&#x27;timeout&#x27;, err)
    that.abort(req)
  })

  req.sender.on(&#x27;sent&#x27;, function() {
    if (req.multicast) return;

    that._msgInFlight--
    if (that._closing &#x26;&#x26; that._msgInFlight === 0) {
      that._doClose()
    }
  })

  // Start multicast monitoring timer in case of multicast request
  if (url.multicast === true) {
    req.multicastTimer = setTimeout(function() {
      that._msgInFlight--
      if (that._msgInFlight === 0) {
        that._doClose()
      }
    }, multicastTimeout)
  }

  if (url.observe)
    req.setOption(&#x27;Observe&#x27;, null)
  else
    req.on(&#x27;response&#x27;, this._cleanUp.bind(this))

  this._requests++

  req._totalPayload = new Buffer(0)

  return req
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

server.on(&#x27;request&#x27;, function(req, res) {
res.end(&#x27;Hello &#x27; + req.url.split(&#x27;/&#x27;)[1] + &#x27;\n&#x27;)
})

// the default CoAP port is 5683
server.listen(function() {
var req = coap.<span class="apidocCodeKeywordSpan">request</span>(&#x27;coap://localhost/Matteo&#x27;)

req.on(&#x27;response&#x27;, function(res) {
  res.pipe(process.stdout)
  res.on(&#x27;end&#x27;, function() {
    process.exit(0)
  })
})
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.coap.Agent.prototype._cleanUp" id="apidoc.module.coap.Agent.prototype._cleanUp">module coap.Agent.prototype._cleanUp</a></h1>


    <h2>
        <a href="#apidoc.element.coap.Agent.prototype._cleanUp._cleanUp" id="apidoc.element.coap.Agent.prototype._cleanUp._cleanUp">
        function <span class="apidocSignatureSpan">coap.Agent.prototype.</span>_cleanUp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cleanUp() {
  if (--this._requests !== 0)
    return

  this._closing = true

  if (this._msgInFlight !== 0)
    return

  this._doClose()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.coap.Agent.prototype._doClose" id="apidoc.module.coap.Agent.prototype._doClose">module coap.Agent.prototype._doClose</a></h1>


    <h2>
        <a href="#apidoc.element.coap.Agent.prototype._doClose._doClose" id="apidoc.element.coap.Agent.prototype._doClose._doClose">
        function <span class="apidocSignatureSpan">coap.Agent.prototype.</span>_doClose
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_doClose = function () {
  for (var k in this._msgIdToReq)
    this._msgIdToReq[k].sender.reset()

  if (this._opts.socket)
    return

  this._sock.close()
  this._sock = null
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.coap.Agent.prototype._handle" id="apidoc.module.coap.Agent.prototype._handle">module coap.Agent.prototype._handle</a></h1>


    <h2>
        <a href="#apidoc.element.coap.Agent.prototype._handle._handle" id="apidoc.element.coap.Agent.prototype._handle._handle">
        function <span class="apidocSignatureSpan">coap.Agent.prototype.</span>_handle
        <span class="apidocSignatureSpan">(msg, rsinfo, outSocket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function handle(msg, rsinfo, outSocket) {
  var packet = parse(msg)
    , buf
    , response
    , that = this
    , req = this._msgIdToReq[packet.messageId]
    , ackSent = function(err) {
        if (err &#x26;&#x26; req)
          req.emit(&#x27;error&#x27;, err)

        that._msgInFlight--
        if (that._closing &#x26;&#x26; that._msgInFlight === 0) {
          that._doClose()
        }
      }

  if (!req) {
    if (packet.token.length == 4) {
      req = this._tkToReq[packet.token.readUInt32BE(0)]
    }

    if (packet.ack &#x26;&#x26; !req) {
      // nothing to do, somehow there was
      // a duplicate ack
      return
    }

    if (!req) {
      buf = generate({
          code: &#x27;0.00&#x27;
        , reset: true
        , messageId: packet.messageId
      })

      this._msgInFlight++
      this._sock.send(buf, 0, buf.length, rsinfo.port, rsinfo.address, ackSent)
      return
    }
  }

  if (packet.confirmable) {
    buf = generate({
        code: &#x27;0.00&#x27;
      , ack: true
      , messageId: packet.messageId
    })

    this._msgInFlight++
    this._sock.send(buf, 0, buf.length, rsinfo.port, rsinfo.address, ackSent)
  }

  if (packet.code != &#x27;0.00&#x27; &#x26;&#x26; (req._packet.token.length != packet.token.length || pf.compareBuffers(req._packet.token, packet.token
) != 0)) {
    // The tokens don&#x27;t match, ignore the message since it is a malformed response
    return
  }

  if (!packet.confirmable &#x26;&#x26; !req.multicast) {
    delete this._msgIdToReq[packet.messageId]
  }

  req.sender.reset()

  if (packet.code == &#x27;0.00&#x27;)
    return

  var block2Buff = getOption(packet.options, &#x27;Block2&#x27;)
  var block2
  // if we got blockwise (2) response
  if (block2Buff) {
    block2 = parseBlock2(block2Buff)
    // check for error
    if (!block2) {
      req.sender.reset()
      return req.emit(&#x27;error&#x27;, new Error(&#x27;failed to parse block2&#x27;))
    }
  }
  if (block2) {
    // accumulate payload
    req._totalPayload = Buffer.concat([req._totalPayload, packet.payload])

    if (block2.moreBlock2) {
      // increase message id for next request
      delete this._msgIdToReq[req._packet.messageId]
      req._packet.messageId = that._nextMessageId()
      this._msgIdToReq[req._packet.messageId] = req

      // next block2 request
      var block2Val = createBlock2({
        moreBlock2: false,
        num: block2.num+1,
        size: block2.size
      })
      if (!block2Val) {
        req.sender.reset()
        return req.emit(&#x27;error&#x27;, new Error(&#x27;failed to create block2&#x27;))
      }
      req.setOption(&#x27;Block2&#x27;, block2Val)
      req.sender.send(generate(req._packet))

      return
    }
    else {
      // get full payload
      packet.payload = req._totalPayload
      // clear the payload incase of block2
      req._totalPayload = new Buffer(0)
    }
  }

  if (req.response) {
    if (req.response.append) {
      // it is an observe request
      // and we are already streaming
      return req.response.append(packet)
    } else {
      // TODO There is a previous response but is not an ObserveStream !
      return
    }

  }
  else if (block2) {
    delete that._tkToReq[req._packet.token.readUInt32BE(0)]
  }
  else if (!req.url.observe &#x26;&#x26; packet.token.length &#x3e; 0) {
    // it is not, so delete the token
    delete that._tkToReq[packet.token.readUInt32BE(0)]
  }

  if (req.url.observe &#x26;&#x26; packet.code !== &#x27;4.04&#x27;) {
    response = new ObserveStream(packet, rsinfo, outSocket)
    response.on(&#x27;close&#x27;, function() {
      delete that._tkToReq[packet.token.readUInt32BE(0)]
      that._cleanUp()
    })
  } else {
    response = new IncomingMessage(packet, rsinfo, outSocket)
  }

  if (!req.multicast) {
    req.response = response
  }

  req.emit(&#x27;response&#x27;, response)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

function handleServerRequest(request, next) {
  if (request.proxy) {
    return next();
  }
  try {
    request.server.<span class="apidocCodeKeywordSpan">_handle</span>(request.packet, request.rsinfo)
    next(null)
  } catch (err) {
    next(err)
  }
}

function proxyRequest(request, next) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.coap.Agent.prototype._init" id="apidoc.module.coap.Agent.prototype._init">module coap.Agent.prototype._init</a></h1>


    <h2>
        <a href="#apidoc.element.coap.Agent.prototype._init._init" id="apidoc.element.coap.Agent.prototype._init._init">
        function <span class="apidocSignatureSpan">coap.Agent.prototype.</span>_init
        <span class="apidocSignatureSpan">(socket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function initSock(socket) {
  if (this._sock) {
    return
  }

  var that = this
  this._sock = socket || dgram.createSocket(this._opts.type)
  this._sock.on(&#x27;message&#x27;, function(msg, rsinfo) {
    var packet
      , message
      , outSocket

    try {
      packet = parse(msg)
    } catch(err) {
      message = generate({ code: &#x27;5.00&#x27;, payload: new Buffer(&#x27;Unable to parse packet&#x27;) })
      that._sock.send(message, 0, message.length,
                      rsinfo.port, rsinfo.address)
      return
    }

    if (packet.code[0] === &#x27;0&#x27; &#x26;&#x26; packet.code !== &#x27;0.00&#x27;) {
      // ignore this packet since it&#x27;s not a response.
      return
    }

    outSocket = that._sock.address();
    that._handle(msg, rsinfo, outSocket)
  })

  if(this._opts.port){
    this._sock.bind( this._opts.port );
  };

  this._sock.on(&#x27;error&#x27;, function(err) {
    // we are skipping DNS errors
    if(!hasDNSbug || err.code !== &#x27;ENOTFOUND&#x27;)
      that.emit(&#x27;error&#x27;, err)
  })

  this._msgIdToReq = {}
  this._tkToReq = {}

  this._lastToken = Math.floor(Math.random() * (maxToken - 1))
  this._lastMessageId = Math.floor(Math.random() * (maxMessageId - 1))

  this._closing = false
  this._msgInFlight = 0
  this._requests = 0
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.coap.Agent.prototype._nextMessageId" id="apidoc.module.coap.Agent.prototype._nextMessageId">module coap.Agent.prototype._nextMessageId</a></h1>


    <h2>
        <a href="#apidoc.element.coap.Agent.prototype._nextMessageId._nextMessageId" id="apidoc.element.coap.Agent.prototype._nextMessageId._nextMessageId">
        function <span class="apidocSignatureSpan">coap.Agent.prototype.</span>_nextMessageId
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nextToken() {
  if (++this._lastMessageId === maxMessageId)
    this._lastMessageId = 1

  return this._lastMessageId
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.coap.Agent.prototype._nextToken" id="apidoc.module.coap.Agent.prototype._nextToken">module coap.Agent.prototype._nextToken</a></h1>


    <h2>
        <a href="#apidoc.element.coap.Agent.prototype._nextToken._nextToken" id="apidoc.element.coap.Agent.prototype._nextToken._nextToken">
        function <span class="apidocSignatureSpan">coap.Agent.prototype.</span>_nextToken
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nextToken() {
  var buf = new Buffer(4)

  if (++this._lastToken === maxToken)
    this._lastToken = 0

  buf.writeUInt32BE(this._lastToken, 0)

  return buf;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.coap.Agent.prototype.abort" id="apidoc.module.coap.Agent.prototype.abort">module coap.Agent.prototype.abort</a></h1>


    <h2>
        <a href="#apidoc.element.coap.Agent.prototype.abort.abort" id="apidoc.element.coap.Agent.prototype.abort.abort">
        function <span class="apidocSignatureSpan">coap.Agent.prototype.</span>abort
        <span class="apidocSignatureSpan">(req)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">abort = function (req) {
  req.sender.removeAllListeners()
  req.sender.reset()
  this._cleanUp()
  delete this._msgIdToReq[req._packet.messageId]
  delete this._tkToReq[req._packet.token.readUInt32BE(0)]
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.coap.Agent.prototype.request" id="apidoc.module.coap.Agent.prototype.request">module coap.Agent.prototype.request</a></h1>


    <h2>
        <a href="#apidoc.element.coap.Agent.prototype.request.request" id="apidoc.element.coap.Agent.prototype.request.request">
        function <span class="apidocSignatureSpan">coap.Agent.prototype.</span>request
        <span class="apidocSignatureSpan">(url)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function request(url) {
  this._init()

  var req
    , response
    , options = url.options || url.headers
    , option
    , that = this
    , multicastTimeout = url.multicastTimeout !== undefined ? parseInt(url.multicastTimeout) : 20000

  req = new OutgoingMessage({}, function(req, packet) {
    var buf

    if (url.confirmable !== false) {
      packet.confirmable = true
    }

    // multicast message should be forced non-confirmable
    if (url.multicast === true) {
      req.multicast = true
      packet.confirmable = false
    }

    if (!(packet.ack || packet.reset)) {
      packet.messageId = that._nextMessageId()
      packet.token = that._nextToken()
    }

    try {
      buf = generate(packet)
    } catch(err) {
      req.sender.reset()
      return req.emit(&#x27;error&#x27;, err)
    }

    that._msgIdToReq[packet.messageId] = req
    that._tkToReq[that._lastToken] = req

    req.sender.send(buf, !packet.confirmable)
  })

  req.sender = new RetrySend(this._sock, url.port, url.hostname || url.host)

  req.url = url

  req.statusCode = url.method || &#x27;GET&#x27;

  urlPropertyToPacketOption(url, req, &#x27;pathname&#x27;, &#x27;Uri-Path&#x27;, &#x27;/&#x27;)
  urlPropertyToPacketOption(url, req, &#x27;query&#x27;, &#x27;Uri-Query&#x27;, &#x27;&#x26;&#x27;)

  if (options) {
    for (option in options) {
      if (options.hasOwnProperty(option)) {
        req.setOption(option, options[option])
      }
    }
  }

  if (url.proxyUri) {
    req.setOption(&#x27;Proxy-Uri&#x27;, url.proxyUri)
  }

  req.sender.on(&#x27;error&#x27;, req.emit.bind(req, &#x27;error&#x27;))

  req.sender.on(&#x27;sending&#x27;, function() {
    that._msgInFlight++
  })

  req.sender.on(&#x27;timeout&#x27;, function (err) {
    req.emit(&#x27;timeout&#x27;, err)
    that.abort(req)
  })

  req.sender.on(&#x27;sent&#x27;, function() {
    if (req.multicast) return;

    that._msgInFlight--
    if (that._closing &#x26;&#x26; that._msgInFlight === 0) {
      that._doClose()
    }
  })

  // Start multicast monitoring timer in case of multicast request
  if (url.multicast === true) {
    req.multicastTimer = setTimeout(function() {
      that._msgInFlight--
      if (that._msgInFlight === 0) {
        that._doClose()
      }
    }, multicastTimeout)
  }

  if (url.observe)
    req.setOption(&#x27;Observe&#x27;, null)
  else
    req.on(&#x27;response&#x27;, this._cleanUp.bind(this))

  this._requests++

  req._totalPayload = new Buffer(0)

  return req
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

server.on(&#x27;request&#x27;, function(req, res) {
res.end(&#x27;Hello &#x27; + req.url.split(&#x27;/&#x27;)[1] + &#x27;\n&#x27;)
})

// the default CoAP port is 5683
server.listen(function() {
var req = coap.<span class="apidocCodeKeywordSpan">request</span>(&#x27;coap://localhost/Matteo&#x27;)

req.on(&#x27;response&#x27;, function(res) {
  res.pipe(process.stdout)
  res.on(&#x27;end&#x27;, function() {
    process.exit(0)
  })
})
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.coap.createServer" id="apidoc.module.coap.createServer">module coap.createServer</a></h1>


    <h2>
        <a href="#apidoc.element.coap.createServer.createServer" id="apidoc.element.coap.createServer.createServer">
        function <span class="apidocSignatureSpan">coap.</span>createServer
        <span class="apidocSignatureSpan">(options, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CoAPServer(options, listener) {
  if (!(this instanceof CoAPServer)) {
    return new CoAPServer(options, listener)
  }

  if (typeof options === &#x27;function&#x27;) {
    listener = options
    options = null
  }

  if (!options)
    options = {}

  this._options = options
  this._proxiedRequests = {}

  this._middlewares = [
    middlewares.parseRequest
  ]

  if (options.proxy) {
    this._middlewares.push(middlewares.proxyRequest)
    this._middlewares.push(middlewares.handleProxyResponse)
  }

  if (!this._options.piggybackReplyMs || !isNumeric(this._options.piggybackReplyMs)) {
    this._options.piggybackReplyMs = parameters.piggybackReplyMs
  }

  if (!isBoolean(this._options.sendAcksForNonConfirmablePackets)) {
    this._options.sendAcksForNonConfirmablePackets = parameters.sendAcksForNonConfirmablePackets
  }
  this._middlewares.push(middlewares.handleServerRequest)

  // Multicast settings
  this._multicastAddress = options.multicastAddress ? options.multicastAddress : null
  this._multicastInterface = options.multicastInterface ? options.multicastInterface : null

  // We use an LRU cache for the responses to avoid
  // DDOS problems.
  // max packet size is 1280
  // 32 MB / 1280 = 26214
  // The max lifetime is roughly 200s per packet.
  // Which gave us 131 packets/second guarantee
  this._lru = LRU({
      max: options.cacheSize || (32768 * 1024)
    , length: function(n) { return n.buffer.byteLength }
    , maxAge: (parameters.exchangeLifetime * 1000)
    , dispose:  function(key, value) {
                  if (value.sender)
                    value.sender.reset()
                }
  })

  this._series = series()
  this._block2Cache = {}

  if (listener)
    this.on(&#x27;request&#x27;, listener)
  debug(&#x27;initialized&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
## Basic Example

The following example opens a UDP server and sends a
CoAP message to it:

```js
var coap        = require(&#x27;coap&#x27;)
  , server      = coap.<span class="apidocCodeKeywordSpan">createServer</span>()

server.on(&#x27;request&#x27;, function(req, res) {
  res.end(&#x27;Hello &#x27; + req.url.split(&#x27;/&#x27;)[1] + &#x27;\n&#x27;)
})

// the default CoAP port is 5683
server.listen(function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.createServer.super_" id="apidoc.element.coap.createServer.super_">
        function <span class="apidocSignatureSpan">coap.createServer.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.coap.createServer.prototype" id="apidoc.module.coap.createServer.prototype">module coap.createServer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.coap.createServer.prototype._handle" id="apidoc.element.coap.createServer.prototype._handle">
        function <span class="apidocSignatureSpan">coap.createServer.prototype.</span>_handle
        <span class="apidocSignatureSpan">(packet, rsinfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_handle = function (packet, rsinfo) {

  if (packet.code[0] !== &#x27;0&#x27;) {
    // According to RFC7252 Section 4.2 receiving a confirmable messages
    // that can&#x27;t be processed, should be rejected by ignoring it AND
    // sending a reset. In this case confirmable response message would
    // be silently ignored, which is not exactly as stated in the standard.
    // However, sending a reset would interfere with a coap client which is
    // re-using a socket (see pull-request #131).
    return
  }

  var sock      = this._sock
    , lru       = this._lru
    , acks      = this._acks
    , cached    = lru.peek(toKey(rsinfo.address, rsinfo.port, packet, true))
    , Message   = OutMessage
    , that = this
    , request
    , response

  if (cached &#x26;&#x26; !packet.ack &#x26;&#x26; !packet.reset) {
    return sock.send(cached, 0, cached.length, rsinfo.port, rsinfo.address)
  } else if (cached &#x26;&#x26; (packet.ack || packet.reset)) {
    if (cached.response &#x26;&#x26; packet.reset) {
      cached.response.end()
    }
    return lru.del(toKey(rsinfo.address, rsinfo.port, packet, false))
  }
  else if (packet.ack || packet.reset) {
    return // nothing to do, ignoring silently
  }

  request = new IncomingMessage(packet, rsinfo)

  if (request.headers[&#x27;Observe&#x27;] === 0) {
    Message = ObserveStream
    if (packet.code !== &#x27;0.01&#x27;)
      // it is not a GET
      return this._sendError(new Buffer(&#x27;Observe can only be present with a GET&#x27;), rsinfo)
  }

  packet.piggybackReplyMs = this._options.piggybackReplyMs;
  response = new Message(packet, function(response, packet) {
    var buf
      , sender = new RetrySend(sock, rsinfo.port, rsinfo.address)

    try {
      buf = generate(packet)
    } catch(err) {
      return response.emit(&#x27;error&#x27;, err)
    }

    if (Message === OutMessage) {
      sender.on(&#x27;error&#x27;, response.emit.bind(response, &#x27;error&#x27;))
    } else {
      buf.response = response
      sender.on(&#x27;error&#x27;, function() {
        response.end()
      })
    }

    var key = toKey(rsinfo.address, rsinfo.port,
        packet, packet.ack || !packet.confirmable)
    lru.set(key, buf)
    buf.sender = sender

    if (that._options.sendAcksForNonConfirmablePackets || packet.confirmable){
      sender.send(buf, packet.ack || packet.reset || packet.confirmable === false)
    } else {
      debug(&#x27;OMIT ACK PACKAGE&#x27;)
    }
  })

  request.rsinfo = rsinfo
  response.statusCode = &#x27;2.05&#x27;
  response._request = request._packet
  response._cachekey = toCacheKey(rsinfo.address, rsinfo.port, packet)

  var block2cache = this._block2Cache
  //inject this function so the response can add an entry to the cache
  response._addCacheEntry = function(key, payload) {
    if (block2cache.hasOwnProperty(key)) {
      debug(&#x27;reuse old cache entry, key:&#x27;, key)
      clearTimeout(block2cache[key].timeoutId) // cancel old expiry timer
      block2cache[key].payload = payload
    } else {
      debug(&#x27;add payload to cache, key:&#x27;, key)
      block2cache[key] = {payload: payload}
    }
    // setup new expiry timer
    block2cache[key].timeoutId = setTimeout(expiry, parameters.exchangeLifetime * 1000, block2cache, key)
  }

  //return cached value for blockwise requests
  var cachedResponseSend = false
  if (packet.token &#x26;&#x26; packet.token.length &#x3e; 0) {
    // return cached value only if this request is not the first block request
    var block2Buff = getOption(response._request.options, &#x27;Block2&#x27;)
    var requestedBlockOption
    if (block2Buff) {
      requestedBlockOption = parseBlock2(block2Buff)
    }
    if (!requestedBlockOption) {
      requestedBlockOption = {num: 0}
    }

    if (requestedBlockOption.num &#x3c; 1) {
      if (this._block2Cache.hasOwnProperty(response._cachekey)) {
        debug(&#x27;first block2 request, remove old entry from cache, key:&#x27;, response._cachekey)
        clearTimeout(this._block2Cache[response._cachekey].timeoutId)
        delete this._block2Cache[response._cachekey]
      }
    } else {
      debug(&#x27;check if packet token is in cache, key:&#x27;, response._cachekey)
      if (this._block2Cache.hasOwnProperty(response._cachekey)) {
        debug(&#x27;found cached payload, key:&#x27; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

function handleServerRequest(request, next) {
  if (request.proxy) {
    return next();
  }
  try {
    request.server.<span class="apidocCodeKeywordSpan">_handle</span>(request.packet, request.rsinfo)
    next(null)
  } catch (err) {
    next(err)
  }
}

function proxyRequest(request, next) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.createServer.prototype._sendError" id="apidoc.element.coap.createServer.prototype._sendError">
        function <span class="apidocSignatureSpan">coap.createServer.prototype.</span>_sendError
        <span class="apidocSignatureSpan">(payload, rsinfo, packet)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_sendError = function (payload, rsinfo, packet) {
  var message = generate({
    code: &#x27;5.00&#x27;,
    payload: payload,
    messageId: (packet)?packet.messageId:undefined,
    token: (packet)?packet.token:undefined
  })

  this._sock.send(message, 0, message.length, rsinfo.port)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.createServer.prototype._sendProxied" id="apidoc.element.coap.createServer.prototype._sendProxied">
        function <span class="apidocSignatureSpan">coap.createServer.prototype.</span>_sendProxied
        <span class="apidocSignatureSpan">(packet, proxyUri, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_sendProxied = function (packet, proxyUri, callback) {
  var url = require(&#x27;url&#x27;).parse(proxyUri)
    , host = url.hostname
    , port = url.port
    , message = generate(removeProxyOptions(packet))

  this._sock.send(message, 0, message.length, port, host, callback)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (request.proxy) {
  if (request.packet.token.length === 0) {
    request.packet.token = crypto.randomBytes(8);
  }

  request.server._proxiedRequests[request.packet.token.toString(&#x27;hex&#x27;)] = request
  request.server.<span class="apidocCodeKeywordSpan">_sendProxied</span>(request.packet, request.proxy, next)
} else {
  next(null)
}
}

function isObserve(packet) {
return packet.options.map(isOption(&#x27;Observe&#x27;)).reduce(or, false);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.createServer.prototype._sendReverseProxied" id="apidoc.element.coap.createServer.prototype._sendReverseProxied">
        function <span class="apidocSignatureSpan">coap.createServer.prototype.</span>_sendReverseProxied
        <span class="apidocSignatureSpan">(packet, rsinfo, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_sendReverseProxied = function (packet, rsinfo, callback) {
  var host = rsinfo.address
    , port = rsinfo.port
    , message = generate(packet)

  this._sock.send(message, 0, message.length, port, host, callback)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function handleProxyResponse(request, next) {
if (request.proxy) {
  return next(null)
}

var originalProxiedRequest = request.server._proxiedRequests[request.packet.token.toString(&#x27;hex&#x27;)]
if ( originalProxiedRequest ) {
  request.server.<span class="apidocCodeKeywordSpan">_sendReverseProxied</span>(request.packet, originalProxiedRequest.rsinfo)

  if (!isObserve(request.packet))
    delete request.server._proxiedRequests[request.packet.token.toString(&#x27;hex&#x27;)]

  next(null)
} else {
  next()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.createServer.prototype.close" id="apidoc.element.coap.createServer.prototype.close">
        function <span class="apidocSignatureSpan">coap.createServer.prototype.</span>close
        <span class="apidocSignatureSpan">(done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (done) {
  if (done) {
    setImmediate(done)
  }

  if (this._lru.pruneTimer) {
    clearInterval(this._lru.pruneTimer)
  }

  if (this._sock) {
    this._sock.close()
    this._lru.reset()
    this._sock = null
    this.emit(&#x27;close&#x27;)
  } else {
    this._lru.reset()
  }

  // cancel cache entry expiry timers
  for (var k in this._block2Cache) {
    if (this._block2Cache.hasOwnProperty(k)) {
      debug(&#x27;clean-up cache expiry timer, key:&#x27;, k)
      clearTimeout(this._block2Cache[k].timeoutId)
      delete this._block2Cache[k]
    }
  }

  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
hostname is omitted, the server will accept connections directed to any
IPv4 or IPv6 address by passing `null` as the address to the underlining socket.

To listen to a unix socket, supply a filename instead of port and hostname.

This function is asynchronous.

#### server.<span class="apidocCodeKeywordSpan">close</span>([callback])

Closes the server.

This function is synchronous, but it provides an asynchronous callback
for convenience.

-------------------------------------------------------
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.createServer.prototype.listen" id="apidoc.element.coap.createServer.prototype.listen">
        function <span class="apidocSignatureSpan">coap.createServer.prototype.</span>listen
        <span class="apidocSignatureSpan">(port, address, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listen = function (port, address, done) {
  var that = this

  if (port == undefined) {
    port = parameters.coapPort
  }

  if (typeof port === &#x27;function&#x27;) {
    done = port
    port = parameters.coapPort
  }

  if (typeof address === &#x27;function&#x27;) {
    done = address
    address = null
  }

  if (this._sock) {
    if (done)
      done(new Error(&#x27;Already listening&#x27;))
    else
      throw new Error(&#x27;Already listening&#x27;)

    return this
  }

  if (address &#x26;&#x26; net.isIPv6(address))
    this._options.type = &#x27;udp6&#x27;

  if (!this._options.type)
    this._options.type = &#x27;udp4&#x27;

  this._sock = dgram.createSocket({type: this._options.type, reuseAddr : true}, handleRequest(this))

  this._sock.on(&#x27;error&#x27;, function(error) {
    that.emit(&#x27;error&#x27;, error)
  })

  this._sock.bind(port, address || null, function () {
    if (that._multicastAddress) {
      that._sock.setMulticastLoopback(true)

      if (that._multicastInterface) {
        that._sock.addMembership(that._multicastAddress, that._multicastInterface)
      } else {
        allAddresses(that._options.type).forEach(function(interface) {
            that._sock.addMembership(that._multicastAddress, interface)
        })
      }
    }
    if (done) done()
  })
  this._port = port
  this._address = address

  if (parameters.pruneTimerPeriod) {
    // Start LRU pruning timer
    this._lru.pruneTimer = setInterval(function () {
      that._lru.prune()
    }, parameters.pruneTimerPeriod*1000)
    if (this._lru.pruneTimer.unref) {
      this._lru.pruneTimer.unref()
    }
  }

  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
, server      = coap.createServer()

server.on(&#x27;request&#x27;, function(req, res) {
res.end(&#x27;Hello &#x27; + req.url.split(&#x27;/&#x27;)[1] + &#x27;\n&#x27;)
})

// the default CoAP port is 5683
server.<span class="apidocCodeKeywordSpan">listen</span>(function() {
var req = coap.request(&#x27;coap://localhost/Matteo&#x27;)

req.on(&#x27;response&#x27;, function(res) {
  res.pipe(process.stdout)
  res.on(&#x27;end&#x27;, function() {
    process.exit(0)
  })
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.coap.createServer.prototype._handle" id="apidoc.module.coap.createServer.prototype._handle">module coap.createServer.prototype._handle</a></h1>


    <h2>
        <a href="#apidoc.element.coap.createServer.prototype._handle._handle" id="apidoc.element.coap.createServer.prototype._handle._handle">
        function <span class="apidocSignatureSpan">coap.createServer.prototype.</span>_handle
        <span class="apidocSignatureSpan">(packet, rsinfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_handle = function (packet, rsinfo) {

  if (packet.code[0] !== &#x27;0&#x27;) {
    // According to RFC7252 Section 4.2 receiving a confirmable messages
    // that can&#x27;t be processed, should be rejected by ignoring it AND
    // sending a reset. In this case confirmable response message would
    // be silently ignored, which is not exactly as stated in the standard.
    // However, sending a reset would interfere with a coap client which is
    // re-using a socket (see pull-request #131).
    return
  }

  var sock      = this._sock
    , lru       = this._lru
    , acks      = this._acks
    , cached    = lru.peek(toKey(rsinfo.address, rsinfo.port, packet, true))
    , Message   = OutMessage
    , that = this
    , request
    , response

  if (cached &#x26;&#x26; !packet.ack &#x26;&#x26; !packet.reset) {
    return sock.send(cached, 0, cached.length, rsinfo.port, rsinfo.address)
  } else if (cached &#x26;&#x26; (packet.ack || packet.reset)) {
    if (cached.response &#x26;&#x26; packet.reset) {
      cached.response.end()
    }
    return lru.del(toKey(rsinfo.address, rsinfo.port, packet, false))
  }
  else if (packet.ack || packet.reset) {
    return // nothing to do, ignoring silently
  }

  request = new IncomingMessage(packet, rsinfo)

  if (request.headers[&#x27;Observe&#x27;] === 0) {
    Message = ObserveStream
    if (packet.code !== &#x27;0.01&#x27;)
      // it is not a GET
      return this._sendError(new Buffer(&#x27;Observe can only be present with a GET&#x27;), rsinfo)
  }

  packet.piggybackReplyMs = this._options.piggybackReplyMs;
  response = new Message(packet, function(response, packet) {
    var buf
      , sender = new RetrySend(sock, rsinfo.port, rsinfo.address)

    try {
      buf = generate(packet)
    } catch(err) {
      return response.emit(&#x27;error&#x27;, err)
    }

    if (Message === OutMessage) {
      sender.on(&#x27;error&#x27;, response.emit.bind(response, &#x27;error&#x27;))
    } else {
      buf.response = response
      sender.on(&#x27;error&#x27;, function() {
        response.end()
      })
    }

    var key = toKey(rsinfo.address, rsinfo.port,
        packet, packet.ack || !packet.confirmable)
    lru.set(key, buf)
    buf.sender = sender

    if (that._options.sendAcksForNonConfirmablePackets || packet.confirmable){
      sender.send(buf, packet.ack || packet.reset || packet.confirmable === false)
    } else {
      debug(&#x27;OMIT ACK PACKAGE&#x27;)
    }
  })

  request.rsinfo = rsinfo
  response.statusCode = &#x27;2.05&#x27;
  response._request = request._packet
  response._cachekey = toCacheKey(rsinfo.address, rsinfo.port, packet)

  var block2cache = this._block2Cache
  //inject this function so the response can add an entry to the cache
  response._addCacheEntry = function(key, payload) {
    if (block2cache.hasOwnProperty(key)) {
      debug(&#x27;reuse old cache entry, key:&#x27;, key)
      clearTimeout(block2cache[key].timeoutId) // cancel old expiry timer
      block2cache[key].payload = payload
    } else {
      debug(&#x27;add payload to cache, key:&#x27;, key)
      block2cache[key] = {payload: payload}
    }
    // setup new expiry timer
    block2cache[key].timeoutId = setTimeout(expiry, parameters.exchangeLifetime * 1000, block2cache, key)
  }

  //return cached value for blockwise requests
  var cachedResponseSend = false
  if (packet.token &#x26;&#x26; packet.token.length &#x3e; 0) {
    // return cached value only if this request is not the first block request
    var block2Buff = getOption(response._request.options, &#x27;Block2&#x27;)
    var requestedBlockOption
    if (block2Buff) {
      requestedBlockOption = parseBlock2(block2Buff)
    }
    if (!requestedBlockOption) {
      requestedBlockOption = {num: 0}
    }

    if (requestedBlockOption.num &#x3c; 1) {
      if (this._block2Cache.hasOwnProperty(response._cachekey)) {
        debug(&#x27;first block2 request, remove old entry from cache, key:&#x27;, response._cachekey)
        clearTimeout(this._block2Cache[response._cachekey].timeoutId)
        delete this._block2Cache[response._cachekey]
      }
    } else {
      debug(&#x27;check if packet token is in cache, key:&#x27;, response._cachekey)
      if (this._block2Cache.hasOwnProperty(response._cachekey)) {
        debug(&#x27;found cached payload, key:&#x27; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

function handleServerRequest(request, next) {
  if (request.proxy) {
    return next();
  }
  try {
    request.server.<span class="apidocCodeKeywordSpan">_handle</span>(request.packet, request.rsinfo)
    next(null)
  } catch (err) {
    next(err)
  }
}

function proxyRequest(request, next) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.coap.createServer.prototype._sendError" id="apidoc.module.coap.createServer.prototype._sendError">module coap.createServer.prototype._sendError</a></h1>


    <h2>
        <a href="#apidoc.element.coap.createServer.prototype._sendError._sendError" id="apidoc.element.coap.createServer.prototype._sendError._sendError">
        function <span class="apidocSignatureSpan">coap.createServer.prototype.</span>_sendError
        <span class="apidocSignatureSpan">(payload, rsinfo, packet)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_sendError = function (payload, rsinfo, packet) {
  var message = generate({
    code: &#x27;5.00&#x27;,
    payload: payload,
    messageId: (packet)?packet.messageId:undefined,
    token: (packet)?packet.token:undefined
  })

  this._sock.send(message, 0, message.length, rsinfo.port)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.coap.createServer.prototype._sendProxied" id="apidoc.module.coap.createServer.prototype._sendProxied">module coap.createServer.prototype._sendProxied</a></h1>


    <h2>
        <a href="#apidoc.element.coap.createServer.prototype._sendProxied._sendProxied" id="apidoc.element.coap.createServer.prototype._sendProxied._sendProxied">
        function <span class="apidocSignatureSpan">coap.createServer.prototype.</span>_sendProxied
        <span class="apidocSignatureSpan">(packet, proxyUri, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_sendProxied = function (packet, proxyUri, callback) {
  var url = require(&#x27;url&#x27;).parse(proxyUri)
    , host = url.hostname
    , port = url.port
    , message = generate(removeProxyOptions(packet))

  this._sock.send(message, 0, message.length, port, host, callback)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (request.proxy) {
  if (request.packet.token.length === 0) {
    request.packet.token = crypto.randomBytes(8);
  }

  request.server._proxiedRequests[request.packet.token.toString(&#x27;hex&#x27;)] = request
  request.server.<span class="apidocCodeKeywordSpan">_sendProxied</span>(request.packet, request.proxy, next)
} else {
  next(null)
}
}

function isObserve(packet) {
return packet.options.map(isOption(&#x27;Observe&#x27;)).reduce(or, false);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.coap.createServer.prototype._sendReverseProxied" id="apidoc.module.coap.createServer.prototype._sendReverseProxied">module coap.createServer.prototype._sendReverseProxied</a></h1>


    <h2>
        <a href="#apidoc.element.coap.createServer.prototype._sendReverseProxied._sendReverseProxied" id="apidoc.element.coap.createServer.prototype._sendReverseProxied._sendReverseProxied">
        function <span class="apidocSignatureSpan">coap.createServer.prototype.</span>_sendReverseProxied
        <span class="apidocSignatureSpan">(packet, rsinfo, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_sendReverseProxied = function (packet, rsinfo, callback) {
  var host = rsinfo.address
    , port = rsinfo.port
    , message = generate(packet)

  this._sock.send(message, 0, message.length, port, host, callback)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function handleProxyResponse(request, next) {
if (request.proxy) {
  return next(null)
}

var originalProxiedRequest = request.server._proxiedRequests[request.packet.token.toString(&#x27;hex&#x27;)]
if ( originalProxiedRequest ) {
  request.server.<span class="apidocCodeKeywordSpan">_sendReverseProxied</span>(request.packet, originalProxiedRequest.rsinfo)

  if (!isObserve(request.packet))
    delete request.server._proxiedRequests[request.packet.token.toString(&#x27;hex&#x27;)]

  next(null)
} else {
  next()
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.coap.createServer.prototype.close" id="apidoc.module.coap.createServer.prototype.close">module coap.createServer.prototype.close</a></h1>


    <h2>
        <a href="#apidoc.element.coap.createServer.prototype.close.close" id="apidoc.element.coap.createServer.prototype.close.close">
        function <span class="apidocSignatureSpan">coap.createServer.prototype.</span>close
        <span class="apidocSignatureSpan">(done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (done) {
  if (done) {
    setImmediate(done)
  }

  if (this._lru.pruneTimer) {
    clearInterval(this._lru.pruneTimer)
  }

  if (this._sock) {
    this._sock.close()
    this._lru.reset()
    this._sock = null
    this.emit(&#x27;close&#x27;)
  } else {
    this._lru.reset()
  }

  // cancel cache entry expiry timers
  for (var k in this._block2Cache) {
    if (this._block2Cache.hasOwnProperty(k)) {
      debug(&#x27;clean-up cache expiry timer, key:&#x27;, k)
      clearTimeout(this._block2Cache[k].timeoutId)
      delete this._block2Cache[k]
    }
  }

  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
hostname is omitted, the server will accept connections directed to any
IPv4 or IPv6 address by passing `null` as the address to the underlining socket.

To listen to a unix socket, supply a filename instead of port and hostname.

This function is asynchronous.

#### server.<span class="apidocCodeKeywordSpan">close</span>([callback])

Closes the server.

This function is synchronous, but it provides an asynchronous callback
for convenience.

-------------------------------------------------------
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.coap.createServer.prototype.listen" id="apidoc.module.coap.createServer.prototype.listen">module coap.createServer.prototype.listen</a></h1>


    <h2>
        <a href="#apidoc.element.coap.createServer.prototype.listen.listen" id="apidoc.element.coap.createServer.prototype.listen.listen">
        function <span class="apidocSignatureSpan">coap.createServer.prototype.</span>listen
        <span class="apidocSignatureSpan">(port, address, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listen = function (port, address, done) {
  var that = this

  if (port == undefined) {
    port = parameters.coapPort
  }

  if (typeof port === &#x27;function&#x27;) {
    done = port
    port = parameters.coapPort
  }

  if (typeof address === &#x27;function&#x27;) {
    done = address
    address = null
  }

  if (this._sock) {
    if (done)
      done(new Error(&#x27;Already listening&#x27;))
    else
      throw new Error(&#x27;Already listening&#x27;)

    return this
  }

  if (address &#x26;&#x26; net.isIPv6(address))
    this._options.type = &#x27;udp6&#x27;

  if (!this._options.type)
    this._options.type = &#x27;udp4&#x27;

  this._sock = dgram.createSocket({type: this._options.type, reuseAddr : true}, handleRequest(this))

  this._sock.on(&#x27;error&#x27;, function(error) {
    that.emit(&#x27;error&#x27;, error)
  })

  this._sock.bind(port, address || null, function () {
    if (that._multicastAddress) {
      that._sock.setMulticastLoopback(true)

      if (that._multicastInterface) {
        that._sock.addMembership(that._multicastAddress, that._multicastInterface)
      } else {
        allAddresses(that._options.type).forEach(function(interface) {
            that._sock.addMembership(that._multicastAddress, interface)
        })
      }
    }
    if (done) done()
  })
  this._port = port
  this._address = address

  if (parameters.pruneTimerPeriod) {
    // Start LRU pruning timer
    this._lru.pruneTimer = setInterval(function () {
      that._lru.prune()
    }, parameters.pruneTimerPeriod*1000)
    if (this._lru.pruneTimer.unref) {
      this._lru.pruneTimer.unref()
    }
  }

  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
, server      = coap.createServer()

server.on(&#x27;request&#x27;, function(req, res) {
res.end(&#x27;Hello &#x27; + req.url.split(&#x27;/&#x27;)[1] + &#x27;\n&#x27;)
})

// the default CoAP port is 5683
server.<span class="apidocCodeKeywordSpan">listen</span>(function() {
var req = coap.request(&#x27;coap://localhost/Matteo&#x27;)

req.on(&#x27;response&#x27;, function(res) {
  res.pipe(process.stdout)
  res.on(&#x27;end&#x27;, function() {
    process.exit(0)
  })
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.coap.defaultTiming" id="apidoc.module.coap.defaultTiming">module coap.defaultTiming</a></h1>


    <h2>
        <a href="#apidoc.element.coap.defaultTiming.defaultTiming" id="apidoc.element.coap.defaultTiming.defaultTiming">
        function <span class="apidocSignatureSpan">coap.</span>defaultTiming
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaultTiming = function () {
  p.refreshTiming(defaultTiming)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.coap.helpers" id="apidoc.module.coap.helpers">module coap.helpers</a></h1>


    <h2>
        <a href="#apidoc.element.coap.helpers.addSetOption" id="apidoc.element.coap.helpers.addSetOption">
        function <span class="apidocSignatureSpan">coap.helpers.</span>addSetOption
        <span class="apidocSignatureSpan">(klass)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addSetOption = function (klass) {
  var proto = klass.prototype
  proto.setOption = setOption
  proto.setHeader = setOption
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (that._counter === 0) { // we have sent no messages
    that._doSend(null)
  }
})
}

util.inherits(ObserveWriteStream, Writable)
helpers.<span class="apidocCodeKeywordSpan">addSetOption</span>(ObserveWriteStream)

ObserveWriteStream.prototype._write = function write(data, encoding, done) {
this.setOption(&#x27;Observe&#x27;, ++this._counter)

if (this._counter === 16777215)
  this._counter = 1
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.helpers.createBlock2" id="apidoc.element.coap.helpers.createBlock2">
        function <span class="apidocSignatureSpan">coap.helpers.</span>createBlock2
        <span class="apidocSignatureSpan">(requestedBlock)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createBlock2(requestedBlock) {
  var byte
  var szx = Math.log(requestedBlock.size)/Math.log(2) - 4
  var m = ((requestedBlock.moreBlock2==true)?0:1)
  var num = requestedBlock.num
  var extraNum

  byte = 0
  byte |= szx
  byte |= m &#x3c;&#x3c; 3
  byte |= (num&#x26;0xf) &#x3c;&#x3c;4

  // total num occupy up to 5 octets
  // num share the higher octet of first byte, and (may) take more 2 bytes for the rest 4 octets
  if (num &#x3c;= 0xf) {
    extraNum = null
  }
  else if (num &#x3c;=0xfff) {
    extraNum = new Buffer([num/16])
  }
  else if (num &#x3c;=0xfffff) {
    extraNum = new Buffer(2)
    extraNum.writeUInt16BE(num&#x3e;&#x3e;4,0)
  }
  else {
    // too big block2 number
    return null
  }
  return (extraNum)? Buffer.concat([extraNum, new Buffer([byte])]):new Buffer([byte])
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.helpers.genAck" id="apidoc.element.coap.helpers.genAck">
        function <span class="apidocSignatureSpan">coap.helpers.</span>genAck
        <span class="apidocSignatureSpan">(request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">genAck = function (request) {
  return {
      messageId: request.messageId
    , code: &#x27;0.00&#x27;
    , options: []
    , confirmable: false
    , ack: true
    , reset: false
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  if (request.confirmable) {
    // replying in piggyback
    this._packet.ack = true

    this._ackTimer = setTimeout(function() {

send(that, helpers.<span class="apidocCodeKeywordSpan">genAck</span>(request))

// we are no more in piggyback
that._packet.confirmable = true
that._packet.ack = false

// we need a new messageId for the CON
// reply
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.helpers.getOption" id="apidoc.element.coap.helpers.getOption">
        function <span class="apidocSignatureSpan">coap.helpers.</span>getOption
        <span class="apidocSignatureSpan">(options, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getOption(options, name) {
  for (var i in options)
    if (options[i].name == name)
      return options[i].value
  return null
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.helpers.isBoolean" id="apidoc.element.coap.helpers.isBoolean">
        function <span class="apidocSignatureSpan">coap.helpers.</span>isBoolean
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isBoolean(n) {
  return typeof(n) === &#x27;boolean&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.helpers.isNumeric" id="apidoc.element.coap.helpers.isNumeric">
        function <span class="apidocSignatureSpan">coap.helpers.</span>isNumeric
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isNumeric(n) {
  return !isNaN(parseFloat(n)) &#x26;&#x26; isFinite(n);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.helpers.isOption" id="apidoc.element.coap.helpers.isOption">
        function <span class="apidocSignatureSpan">coap.helpers.</span>isOption
        <span class="apidocSignatureSpan">(optionName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isOption(optionName) {
  return function(option) {
    return option.name === optionName;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.helpers.or" id="apidoc.element.coap.helpers.or">
        function <span class="apidocSignatureSpan">coap.helpers.</span>or
        <span class="apidocSignatureSpan">(previous, current)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function or(previous, current) {
    return previous || current;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.helpers.packetToMessage" id="apidoc.element.coap.helpers.packetToMessage">
        function <span class="apidocSignatureSpan">coap.helpers.</span>packetToMessage
        <span class="apidocSignatureSpan">(dest, packet)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function packetToMessage(dest, packet) {

  var i
    , options = packet.options
    , option
    , paths   = []
    , queries = []
    , query   = &#x27;&#x27;

  dest.payload = packet.payload
  dest.options = packet.options
  dest.code    = packet.code
  dest.method  = codes[packet.code]
  dest.headers = {}

  for (i=0; i &#x3c; options.length; i++) {
    option = options[i]

    if (option.name === &#x27;Uri-Path&#x27;) {
      paths.push(option.value)
    }

    if (option.name === &#x27;Uri-Query&#x27;) {
      queries.push(option.value)
    }

    option.value = fromBinary(option.name, option.value)

    if (!Buffer.isBuffer(option.value))
      dest.headers[option.name] = option.value
  }

  if (dest.headers[&#x27;Content-Format&#x27;])
    dest.headers[&#x27;Content-Type&#x27;] = dest.headers[&#x27;Content-Format&#x27;]

  query = queries.join(&#x27;&#x26;&#x27;)
  dest.url = &#x27;/&#x27; + paths.join(&#x27;/&#x27;)
  if (query) {
    dest.url += &#x27;?&#x27; + query
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.helpers.parseBlock2" id="apidoc.element.coap.helpers.parseBlock2">
        function <span class="apidocSignatureSpan">coap.helpers.</span>parseBlock2
        <span class="apidocSignatureSpan">(block2Value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseBlock2(block2Value) {
  var num
  switch (block2Value.length) {
    case 1:
    num = block2Value[0] &#x3e;&#x3e; 4
    break
    case 2:
    num = (block2Value[0]*256 + block2Value[1]) &#x3e;&#x3e; 4
    break
    case 3:
    num = (block2Value[0]*256*256 + block2Value[1]*256 + block2Value[2]) &#x3e;&#x3e;4
    break
    default:
    // Block2 is more than 3 bytes
    return null
  }
  // limit value of size is 1024 (2**(6+4))
  if (block2Value.slice(-1)[0] == 7) {
    // Block size is bigger than 1024
    return null
  }
  return {
    moreBlock2: (block2Value.slice(-1)[0] &#x26; (0x01&#x3c;&#x3c;3))? true:false,
    num: num,
    size: Math.pow(2, (block2Value.slice(-1)[0] &#x26; 0x07)+4)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.helpers.toCode" id="apidoc.element.coap.helpers.toCode">
        function <span class="apidocSignatureSpan">coap.helpers.</span>toCode
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toCode(code) {
  if (typeof code === &#x27;string&#x27;)
    return code

  var first  = Math.floor(code / 100)
    , second = code - first * 100
    , result = &#x27;&#x27;

  result += first + &#x27;.&#x27;

  if (second &#x3c; 10)
    result += &#x27;0&#x27;

  result += second

  return result
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.coap.ignoreOption" id="apidoc.module.coap.ignoreOption">module coap.ignoreOption</a></h1>


    <h2>
        <a href="#apidoc.element.coap.ignoreOption.ignoreOption" id="apidoc.element.coap.ignoreOption.ignoreOption">
        function <span class="apidocSignatureSpan">coap.</span>ignoreOption
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ignoreOption = function (name) {
  ignoredOptions[name] = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Register a new option to be converted to string and added to the
`message.headers`.
`toBinary` is a function that accept a string and returns a `Buffer`.
`toString` is a function that accept a `Buffer` and returns a `String`.

-------------------------------------------------------
&#x3c;a name=&#x22;ignoreOption&#x22;&#x3e;&#x3c;/a&#x3e;
### coap.<span class="apidocCodeKeywordSpan">ignoreOption</span>(name)

Explicitly ignore an option; useful for compatibility with `http`-based
modules.

-------------------------------------------------------
&#x3c;a name=&#x22;registerFormat&#x22;&#x3e;&#x3c;/a&#x3e;
### coap.registerFormat(name, value)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.coap.incoming_message" id="apidoc.module.coap.incoming_message">module coap.incoming_message</a></h1>


    <h2>
        <a href="#apidoc.element.coap.incoming_message.incoming_message" id="apidoc.element.coap.incoming_message.incoming_message">
        function <span class="apidocSignatureSpan">coap.</span>incoming_message
        <span class="apidocSignatureSpan">(packet, rsinfo, outSocket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function IncomingMessage(packet, rsinfo, outSocket) {
  Readable.call(this)

  pktToMsg(this, packet)

  this.rsinfo = rsinfo
  this.outSocket = outSocket

  this._packet = packet
  this._payloadIndex = 0
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.incoming_message.super_" id="apidoc.element.coap.incoming_message.super_">
        function <span class="apidocSignatureSpan">coap.incoming_message.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Readable(options) {
  Duplex = Duplex || require(&#x27;./_stream_duplex&#x27;);

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options &#x26;&#x26; typeof options.read === &#x27;function&#x27;) this._read = options.read;

  Stream.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.coap.incoming_message.prototype" id="apidoc.module.coap.incoming_message.prototype">module coap.incoming_message.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.coap.incoming_message.prototype._read" id="apidoc.element.coap.incoming_message.prototype._read">
        function <span class="apidocSignatureSpan">coap.incoming_message.prototype.</span>_read
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_read = function (size) {
  var end     = this._payloadIndex + size
    , start   = this._payloadIndex
    , payload = this._packet.payload
    , buf     = null

  if (start &#x3c; payload.length)
    buf = payload.slice(start, end)

  this._payloadIndex = end
  this.push(buf)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.coap.middlewares" id="apidoc.module.coap.middlewares">module coap.middlewares</a></h1>


    <h2>
        <a href="#apidoc.element.coap.middlewares.handleProxyResponse" id="apidoc.element.coap.middlewares.handleProxyResponse">
        function <span class="apidocSignatureSpan">coap.middlewares.</span>handleProxyResponse
        <span class="apidocSignatureSpan">(request, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function handleProxyResponse(request, next) {
  if (request.proxy) {
    return next(null)
  }

  var originalProxiedRequest = request.server._proxiedRequests[request.packet.token.toString(&#x27;hex&#x27;)]
  if ( originalProxiedRequest ) {
    request.server._sendReverseProxied(request.packet, originalProxiedRequest.rsinfo)

    if (!isObserve(request.packet))
      delete request.server._proxiedRequests[request.packet.token.toString(&#x27;hex&#x27;)]

    next(null)
  } else {
    next()
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.middlewares.handleServerRequest" id="apidoc.element.coap.middlewares.handleServerRequest">
        function <span class="apidocSignatureSpan">coap.middlewares.</span>handleServerRequest
        <span class="apidocSignatureSpan">(request, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function handleServerRequest(request, next) {
  if (request.proxy) {
    return next();
  }
  try {
    request.server._handle(request.packet, request.rsinfo)
    next(null)
  } catch (err) {
    next(err)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.middlewares.parseRequest" id="apidoc.element.coap.middlewares.parseRequest">
        function <span class="apidocSignatureSpan">coap.middlewares.</span>parseRequest
        <span class="apidocSignatureSpan">(request, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseRequest(request, next) {
  try {
    request.packet = parse(request.raw)
    next(null)
  } catch (err) {
    next(err)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.middlewares.proxyRequest" id="apidoc.element.coap.middlewares.proxyRequest">
        function <span class="apidocSignatureSpan">coap.middlewares.</span>proxyRequest
        <span class="apidocSignatureSpan">(request, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function proxyRequest(request, next) {
  for (var i = 0; i &#x3c; request.packet.options.length; i++) {
    if (request.packet.options[i].name.toLowerCase() === &#x27;proxy-uri&#x27;) {
      request.proxy = request.packet.options[i].value.toString()
    }
  }

  if (request.proxy) {
    if (request.packet.token.length === 0) {
      request.packet.token = crypto.randomBytes(8);
    }

    request.server._proxiedRequests[request.packet.token.toString(&#x27;hex&#x27;)] = request
    request.server._sendProxied(request.packet, request.proxy, next)
  } else {
    next(null)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.coap.observe_read_stream" id="apidoc.module.coap.observe_read_stream">module coap.observe_read_stream</a></h1>


    <h2>
        <a href="#apidoc.element.coap.observe_read_stream.observe_read_stream" id="apidoc.element.coap.observe_read_stream.observe_read_stream">
        function <span class="apidocSignatureSpan">coap.</span>observe_read_stream
        <span class="apidocSignatureSpan">(packet, rsinfo, outSocket)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ObserveReadStream(packet, rsinfo, outSocket) {
  Readable.call(this, { objectMode: true })

  this.rsinfo = rsinfo
  this.outSocket = outSocket

  this._lastId = 0
  this.append(packet)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.observe_read_stream.super_" id="apidoc.element.coap.observe_read_stream.super_">
        function <span class="apidocSignatureSpan">coap.observe_read_stream.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Readable(options) {
  Duplex = Duplex || require(&#x27;./_stream_duplex&#x27;);

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options &#x26;&#x26; typeof options.read === &#x27;function&#x27;) this._read = options.read;

  Stream.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.coap.observe_read_stream.prototype" id="apidoc.module.coap.observe_read_stream.prototype">module coap.observe_read_stream.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.coap.observe_read_stream.prototype._read" id="apidoc.element.coap.observe_read_stream.prototype._read">
        function <span class="apidocSignatureSpan">coap.observe_read_stream.prototype.</span>_read
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_read = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.observe_read_stream.prototype.append" id="apidoc.element.coap.observe_read_stream.prototype.append">
        function <span class="apidocSignatureSpan">coap.observe_read_stream.prototype.</span>append
        <span class="apidocSignatureSpan">(packet)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">append = function (packet) {
  if (!this.readable)
    return

  pktToMsg(this, packet)
  if (this.headers[&#x27;Observe&#x27;] &#x3e; this._lastId) {
    this._lastId = this.headers[&#x27;Observe&#x27;]
    this.push(packet.payload)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function ObserveReadStream(packet, rsinfo, outSocket) {
Readable.call(this, { objectMode: true })

this.rsinfo = rsinfo
this.outSocket = outSocket

this._lastId = 0
this.<span class="apidocCodeKeywordSpan">append</span>(packet)
}

util.inherits(ObserveReadStream, Readable)

ObserveReadStream.prototype.append = function(packet) {
if (!this.readable)
  return
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.observe_read_stream.prototype.close" id="apidoc.element.coap.observe_read_stream.prototype.close">
        function <span class="apidocSignatureSpan">coap.observe_read_stream.prototype.</span>close
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function () {
  this.push(null)
  this.emit(&#x27;close&#x27;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
hostname is omitted, the server will accept connections directed to any
IPv4 or IPv6 address by passing `null` as the address to the underlining socket.

To listen to a unix socket, supply a filename instead of port and hostname.

This function is asynchronous.

#### server.<span class="apidocCodeKeywordSpan">close</span>([callback])

Closes the server.

This function is synchronous, but it provides an asynchronous callback
for convenience.

-------------------------------------------------------
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.coap.observe_write_stream" id="apidoc.module.coap.observe_write_stream">module coap.observe_write_stream</a></h1>


    <h2>
        <a href="#apidoc.element.coap.observe_write_stream.observe_write_stream" id="apidoc.element.coap.observe_write_stream.observe_write_stream">
        function <span class="apidocSignatureSpan">coap.</span>observe_write_stream
        <span class="apidocSignatureSpan">(request, send)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ObserveWriteStream(request, send) {
  Writable.call(this)

  this._packet = {
      token: request.token
    , messageId: request.messageId
    , options: []
    , confirmable: false
    , ack: request.confirmable
    , reset: false
  }

  this._request = request
  this._send = send
  this.statusCode = &#x27;&#x27;

  this._counter = 0

  var that = this
  this.on(&#x27;finish&#x27;, function() {
    if (that._counter === 0) { // we have sent no messages
      that._doSend(null)
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.observe_write_stream.super_" id="apidoc.element.coap.observe_write_stream.super_">
        function <span class="apidocSignatureSpan">coap.observe_write_stream.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Writable(options) {
  Duplex = Duplex || require(&#x27;./_stream_duplex&#x27;);

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) &#x26;&#x26; !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === &#x27;function&#x27;) this._write = options.write;

    if (typeof options.writev === &#x27;function&#x27;) this._writev = options.writev;
  }

  Stream.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.coap.observe_write_stream.prototype" id="apidoc.module.coap.observe_write_stream.prototype">module coap.observe_write_stream.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.coap.observe_write_stream.prototype._doSend" id="apidoc.element.coap.observe_write_stream.prototype._doSend">
        function <span class="apidocSignatureSpan">coap.observe_write_stream.prototype.</span>_doSend
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doSend(data) {
  var packet = this._packet
  packet.code = this.statusCode
  packet.payload = data
  this._send(this, packet)

  this._packet.confirmable = this._request.confirmable
  this._packet.ack = !this._request.confirmable
  delete this._packet.messageId
  delete this._packet.payload
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.statusCode = &#x27;&#x27;

  this._counter = 0

  var that = this
  this.on(&#x27;finish&#x27;, function() {
    if (that._counter === 0) { // we have sent no messages
      that.<span class="apidocCodeKeywordSpan">_doSend</span>(null)
    }
  })
}

util.inherits(ObserveWriteStream, Writable)
helpers.addSetOption(ObserveWriteStream)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.observe_write_stream.prototype._write" id="apidoc.element.coap.observe_write_stream.prototype._write">
        function <span class="apidocSignatureSpan">coap.observe_write_stream.prototype.</span>_write
        <span class="apidocSignatureSpan">(data, encoding, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function write(data, encoding, done) {
  this.setOption(&#x27;Observe&#x27;, ++this._counter)

  if (this._counter === 16777215)
    this._counter = 1

  this._doSend(data)

  done()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.observe_write_stream.prototype.reset" id="apidoc.element.coap.observe_write_stream.prototype.reset">
        function <span class="apidocSignatureSpan">coap.observe_write_stream.prototype.</span>reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reset() {
  var packet = this._packet
  packet.code = &#x27;0.00&#x27;
  packet.payload = &#x27;&#x27;
  packet.reset = true;
  packet.ack = false
  packet.token = new Buffer(0);

  this._send(this, packet)

  this._packet.confirmable = this._request.confirmable
  delete this._packet.messageId
  delete this._packet.payload
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
them by adding a `req.setOption(&#x27;Block2&#x27;, new Buffer([0x2]))` to the
output of [request](#request).

See the
[spec](http://tools.ietf.org/html/draft-ietf-core-coap-18#section-5.4)
for all the possible options.

#### message.<span class="apidocCodeKeywordSpan">reset</span>()
Returns a Reset COAP Message to the sender. The RST message will appear as an empty message with code `0.00` and the
reset flag set to `true` to the caller. This action ends the interaction with the caller.

#### message.writeHead(code, headers)
Functions somewhat like `http`&#x27;s `writeHead()` function.  If `code` is does not match the CoAP code mask of `#.##`, it is coerced
 into this mask.  `headers` is an object with keys being the header names, and values being the header values.

-------------------------------------------------------
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.observe_write_stream.prototype.setHeader" id="apidoc.element.coap.observe_write_stream.prototype.setHeader">
        function <span class="apidocSignatureSpan">coap.observe_write_stream.prototype.</span>setHeader
        <span class="apidocSignatureSpan">(name, values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setOption(name, values) {
  var i

  name = capitalize.words(name)
  name = optionAliases[name] || name

  if (isIgnored(name)) {
    return this
  }

  this._packet.options = this._packet.options.filter(function(option) {
    return option.name !== name
  })

  if (!Array.isArray(values))
    values = [values]

  for (i = 0; i &#x3c; values.length; i++) {
    this._packet.options.push({
        name: name
      , value: toBinary(name, values[i])
    })
  }

  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.observe_write_stream.prototype.setOption" id="apidoc.element.coap.observe_write_stream.prototype.setOption">
        function <span class="apidocSignatureSpan">coap.observe_write_stream.prototype.</span>setOption
        <span class="apidocSignatureSpan">(name, values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setOption(name, values) {
  var i

  name = capitalize.words(name)
  name = optionAliases[name] || name

  if (isIgnored(name)) {
    return this
  }

  this._packet.options = this._packet.options.filter(function(option) {
    return option.name !== name
  })

  if (!Array.isArray(values))
    values = [values]

  for (i = 0; i &#x3c; values.length; i++) {
    this._packet.options.push({
        name: name
      , value: toBinary(name, values[i])
    })
  }

  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
It is HTTP-compatible, as it can be passed `404`.

#### message.statusCode

(same as message.code)

&#x3c;a name=&#x22;setOption&#x22;&#x3e;&#x3c;/a&#x3e;
#### message.<span class="apidocCodeKeywordSpan">setOption</span>(name, value)

Sets a single option value.
All the options are in binary format, except for
`&#x27;Content-Format&#x27;`, `&#x27;Accept&#x27;`, `&#x27;Max-Age&#x27;` and `&#x27;ETag&#x27;`.
See &#x3c;a href=&#x27;#registerOption&#x27;&#x3e;&#x3c;code&#x3e;registerOption&#x3c;/code&#x3e;&#x3c;/a&#x3e;
to know how to register more.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.coap.option_converter" id="apidoc.module.coap.option_converter">module coap.option_converter</a></h1>


    <h2>
        <a href="#apidoc.element.coap.option_converter.fromBinary" id="apidoc.element.coap.option_converter.fromBinary">
        function <span class="apidocSignatureSpan">coap.option_converter.</span>fromBinary
        <span class="apidocSignatureSpan">(name, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromBinary = function (name, value) {
  var convert = optionFromBinaryFunctions[name]

  if (!convert)
    return value

  return convert(value)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.option_converter.ignoreOption" id="apidoc.element.coap.option_converter.ignoreOption">
        function <span class="apidocSignatureSpan">coap.option_converter.</span>ignoreOption
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ignoreOption = function (name) {
  ignoredOptions[name] = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Register a new option to be converted to string and added to the
`message.headers`.
`toBinary` is a function that accept a string and returns a `Buffer`.
`toString` is a function that accept a `Buffer` and returns a `String`.

-------------------------------------------------------
&#x3c;a name=&#x22;ignoreOption&#x22;&#x3e;&#x3c;/a&#x3e;
### coap.<span class="apidocCodeKeywordSpan">ignoreOption</span>(name)

Explicitly ignore an option; useful for compatibility with `http`-based
modules.

-------------------------------------------------------
&#x3c;a name=&#x22;registerFormat&#x22;&#x3e;&#x3c;/a&#x3e;
### coap.registerFormat(name, value)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.option_converter.isIgnored" id="apidoc.element.coap.option_converter.isIgnored">
        function <span class="apidocSignatureSpan">coap.option_converter.</span>isIgnored
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isIgnored = function (name) {
  return !!ignoredOptions[name]
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.option_converter.registerFormat" id="apidoc.element.coap.option_converter.registerFormat">
        function <span class="apidocSignatureSpan">coap.option_converter.</span>registerFormat
        <span class="apidocSignatureSpan">(name, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerFormat = function (name, value) {
  var bytes;

  if (value &#x3e; 255) {
    bytes = new Buffer(2);
    bytes.writeUInt16BE(value, 0);
  } else {
    bytes = new Buffer([value])
  }

  formatsString[name] = bytes
  formatsBinaries[value] = name
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### coap.ignoreOption(name)

Explicitly ignore an option; useful for compatibility with `http`-based
modules.

-------------------------------------------------------
&#x3c;a name=&#x22;registerFormat&#x22;&#x3e;&#x3c;/a&#x3e;
### coap.<span class="apidocCodeKeywordSpan">registerFormat</span>(name, value)

Register a new format to be interpreted and sent in CoAP
`Content-Format` option.
Each format is identified by a number, see the [Content-Format
registry](http://tools.ietf.org/html/draft-ietf-core-coap-18#section-12.3).

These are the defaults formats:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.option_converter.registerOption" id="apidoc.element.coap.option_converter.registerOption">
        function <span class="apidocSignatureSpan">coap.option_converter.</span>registerOption
        <span class="apidocSignatureSpan">(name, toBinary, fromBinary)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerOption = function (name, toBinary, fromBinary) {
  optionFromBinaryFunctions[name] = fromBinary
  optionToBinaryFunctions[name] = toBinary
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

#### reset()
Returns a Reset COAP Message to the sender. The RST message will appear as an empty message with code `0.00` and the
reset flag set to `true` to the caller. This action ends the interaction with the caller.

-------------------------------------------------------
&#x3c;a name=&#x22;registerOption&#x22;&#x3e;&#x3c;/a&#x3e;
### coap.<span class="apidocCodeKeywordSpan">registerOption</span>(name, toBinary, toString)

Register a new option to be converted to string and added to the
`message.headers`.
`toBinary` is a function that accept a string and returns a `Buffer`.
`toString` is a function that accept a `Buffer` and returns a `String`.

-------------------------------------------------------
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.option_converter.toBinary" id="apidoc.element.coap.option_converter.toBinary">
        function <span class="apidocSignatureSpan">coap.option_converter.</span>toBinary
        <span class="apidocSignatureSpan">(name, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBinary = function (name, value) {
  if (Buffer.isBuffer(value))
    return value

  if (!optionToBinaryFunctions[name])
    throw new Error(&#x27;Unknown string to Buffer converter for option: &#x27; + name)

  return optionToBinaryFunctions[name](value)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.coap.outgoing_message" id="apidoc.module.coap.outgoing_message">module coap.outgoing_message</a></h1>


    <h2>
        <a href="#apidoc.element.coap.outgoing_message.outgoing_message" id="apidoc.element.coap.outgoing_message.outgoing_message">
        function <span class="apidocSignatureSpan">coap.</span>outgoing_message
        <span class="apidocSignatureSpan">(request, send)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function OutgoingMessage(request, send) {
  BufferList.call(this)

  this._packet = {
      messageId: request.messageId
    , token: request.token
    , options: []
    , confirmable: false
    , ack: false
    , reset: false
  }

  var that = this

  if (request.confirmable) {
    // replying in piggyback
    this._packet.ack = true

    this._ackTimer = setTimeout(function() {

      send(that, helpers.genAck(request))

      // we are no more in piggyback
      that._packet.confirmable = true
      that._packet.ack = false

      // we need a new messageId for the CON
      // reply
      delete that._packet.messageId

      that._ackTimer = null

    }, request.piggybackReplyMs)
  }

  this._send = send

  this.statusCode = &#x27;&#x27;
  this.code = &#x27;&#x27;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.outgoing_message.super_" id="apidoc.element.coap.outgoing_message.super_">
        function <span class="apidocSignatureSpan">coap.outgoing_message.</span>super_
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BufferList(callback) {
  if (!(this instanceof BufferList))
    return new BufferList(callback)

  this._bufs  = []
  this.length = 0

  if (typeof callback == &#x27;function&#x27;) {
    this._callback = callback

    var piper = function piper (err) {
      if (this._callback) {
        this._callback(err)
        this._callback = null
      }
    }.bind(this)

    this.on(&#x27;pipe&#x27;, function onPipe (src) {
      src.on(&#x27;error&#x27;, piper)
    })
    this.on(&#x27;unpipe&#x27;, function onUnpipe (src) {
      src.removeListener(&#x27;error&#x27;, piper)
    })
  } else {
    this.append(callback)
  }

  DuplexStream.call(this)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.coap.outgoing_message.prototype" id="apidoc.module.coap.outgoing_message.prototype">module coap.outgoing_message.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.coap.outgoing_message.prototype.end" id="apidoc.element.coap.outgoing_message.prototype.end">
        function <span class="apidocSignatureSpan">coap.outgoing_message.prototype.</span>end
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function (a, b) {
  BufferList.prototype.end.call(this, a, b)

  var packet = this._packet
    , message
    , that = this

  packet.code = toCode(this.code || this.statusCode)
  packet.payload = this
  this._send(this, packet)

  // easy clean up after generating the packet
  delete this._packet.payload

  if (this._ackTimer)
    clearTimeout(this._ackTimer)

  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
CoAP message to it:

```js
var coap        = require(&#x27;coap&#x27;)
, server      = coap.createServer()

server.on(&#x27;request&#x27;, function(req, res) {
res.<span class="apidocCodeKeywordSpan">end</span>(&#x27;Hello &#x27; + req.url.split(&#x27;/&#x27;)[1] + &#x27;\n&#x27;)
})

// the default CoAP port is 5683
server.listen(function() {
var req = coap.request(&#x27;coap://localhost/Matteo&#x27;)

req.on(&#x27;response&#x27;, function(res) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.outgoing_message.prototype.reset" id="apidoc.element.coap.outgoing_message.prototype.reset">
        function <span class="apidocSignatureSpan">coap.outgoing_message.prototype.</span>reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reset = function () {
  BufferList.prototype.end.call(this)

  var packet = this._packet
    , message
    , that = this

  packet.code = &#x27;0.00&#x27;
  packet.payload = &#x27;&#x27;
  packet.reset = true;
  packet.ack = false

  this._send(this, packet)

  // easy clean up after generating the packet
  delete this._packet.payload

  if (this._ackTimer)
    clearTimeout(this._ackTimer)

  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
them by adding a `req.setOption(&#x27;Block2&#x27;, new Buffer([0x2]))` to the
output of [request](#request).

See the
[spec](http://tools.ietf.org/html/draft-ietf-core-coap-18#section-5.4)
for all the possible options.

#### message.<span class="apidocCodeKeywordSpan">reset</span>()
Returns a Reset COAP Message to the sender. The RST message will appear as an empty message with code `0.00` and the
reset flag set to `true` to the caller. This action ends the interaction with the caller.

#### message.writeHead(code, headers)
Functions somewhat like `http`&#x27;s `writeHead()` function.  If `code` is does not match the CoAP code mask of `#.##`, it is coerced
 into this mask.  `headers` is an object with keys being the header names, and values being the header values.

-------------------------------------------------------
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.outgoing_message.prototype.setHeader" id="apidoc.element.coap.outgoing_message.prototype.setHeader">
        function <span class="apidocSignatureSpan">coap.outgoing_message.prototype.</span>setHeader
        <span class="apidocSignatureSpan">(name, values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setOption(name, values) {
  var i

  name = capitalize.words(name)
  name = optionAliases[name] || name

  if (isIgnored(name)) {
    return this
  }

  this._packet.options = this._packet.options.filter(function(option) {
    return option.name !== name
  })

  if (!Array.isArray(values))
    values = [values]

  for (i = 0; i &#x3c; values.length; i++) {
    this._packet.options.push({
        name: name
      , value: toBinary(name, values[i])
    })
  }

  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.outgoing_message.prototype.setOption" id="apidoc.element.coap.outgoing_message.prototype.setOption">
        function <span class="apidocSignatureSpan">coap.outgoing_message.prototype.</span>setOption
        <span class="apidocSignatureSpan">(name, values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setOption(name, values) {
  var i

  name = capitalize.words(name)
  name = optionAliases[name] || name

  if (isIgnored(name)) {
    return this
  }

  this._packet.options = this._packet.options.filter(function(option) {
    return option.name !== name
  })

  if (!Array.isArray(values))
    values = [values]

  for (i = 0; i &#x3c; values.length; i++) {
    this._packet.options.push({
        name: name
      , value: toBinary(name, values[i])
    })
  }

  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
It is HTTP-compatible, as it can be passed `404`.

#### message.statusCode

(same as message.code)

&#x3c;a name=&#x22;setOption&#x22;&#x3e;&#x3c;/a&#x3e;
#### message.<span class="apidocCodeKeywordSpan">setOption</span>(name, value)

Sets a single option value.
All the options are in binary format, except for
`&#x27;Content-Format&#x27;`, `&#x27;Accept&#x27;`, `&#x27;Max-Age&#x27;` and `&#x27;ETag&#x27;`.
See &#x3c;a href=&#x27;#registerOption&#x27;&#x3e;&#x3c;code&#x3e;registerOption&#x3c;/code&#x3e;&#x3c;/a&#x3e;
to know how to register more.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.outgoing_message.prototype.writeHead" id="apidoc.element.coap.outgoing_message.prototype.writeHead">
        function <span class="apidocSignatureSpan">coap.outgoing_message.prototype.</span>writeHead
        <span class="apidocSignatureSpan">(code, headers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeHead = function (code, headers) {
  var packet = this._packet
  var header
  packet.code = String(code).replace(/(^\d[^.])/, &#x27;$1.&#x27;)
  for (header in headers) {
    if (headers.hasOwnProperty(header)) {
      this.setOption(header, headers[header])
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
[spec](http://tools.ietf.org/html/draft-ietf-core-coap-18#section-5.4)
for all the possible options.

#### message.reset()
Returns a Reset COAP Message to the sender. The RST message will appear as an empty message with code `0.00` and the
reset flag set to `true` to the caller. This action ends the interaction with the caller.

#### message.<span class="apidocCodeKeywordSpan">writeHead</span>(code, headers)
Functions somewhat like `http`&#x27;s `writeHead()` function.  If `code` is does not match the CoAP code mask of `#.##`, it is coerced
 into this mask.  `headers` is an object with keys being the header names, and values being the header values.

-------------------------------------------------------
&#x3c;a name=&#x22;incoming&#x22;&#x3e;&#x3c;/a&#x3e;
### IncomingMessage

An `IncomingMessage` object is created by `coap.createServer` or
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.coap.parameters" id="apidoc.module.coap.parameters">module coap.parameters</a></h1>




    <h2>
        <a href="#apidoc.element.coap.parameters.defaultTiming" id="apidoc.element.coap.parameters.defaultTiming">
        function <span class="apidocSignatureSpan">coap.parameters.</span>defaultTiming
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaultTiming = function () {
  p.refreshTiming(defaultTiming)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.parameters.refreshTiming" id="apidoc.element.coap.parameters.refreshTiming">
        function <span class="apidocSignatureSpan">coap.parameters.</span>refreshTiming
        <span class="apidocSignatureSpan">(values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">refreshTiming = function (values) {
  for (var key in values){
    if (p[key]) {
      p[key] = values[key]
    }
  }

  // MAX_TRANSMIT_SPAN is the maximum time from the first transmission
  // of a Confirmable message to its last retransmission.
  p.maxTransmitSpan = p.ackTimeout * ((Math.pow(2, p.maxRetransmit)) - 1) * p.ackRandomFactor

  // MAX_TRANSMIT_WAIT is the maximum time from the first transmission
  // of a Confirmable message to the time when the sender gives up on
  // receiving an acknowledgement or reset.
  p.maxTransmitWait = p.ackTimeout * (Math.pow(2, p.maxRetransmit + 1) - 1) * p.ackRandomFactor

  // PROCESSING_DELAY is the time a node takes to turn around a
  // Confirmable message into an acknowledgement.
  p.processingDelay = p.ackTimeout

  // MAX_RTT is the maximum round-trip time
  p.maxRTT = 2 * p.maxLatency + p.processingDelay

  //  EXCHANGE_LIFETIME is the time from starting to send a Confirmable
  //  message to the time when an acknowledgement is no longer expected,
  //  i.e.  message layer information about the message exchange can be
  //  purged
  p.exchangeLifetime = p.maxTransmitSpan + p.maxRTT

  // LRU prune timer period.
  // In order to reduce unnecessary heap usage on low-traffic servers the
  // LRU cache is periodically pruned to remove old, expired packets. This
  // is a fairly low-intensity task, but the period can be altered here
  // or the timer disabled by setting the value to zero.
  // By default the value is set to 0.5 x exchangeLifetime (~120s)
  if (values &#x26;&#x26; (typeof(values.pruneTimerPeriod)===&#x22;number&#x22;)) {
    p.pruneTimerPeriod = values.pruneTimerPeriod
  } else {
    p.pruneTimerPeriod =  (0.5 * p.exchangeLifetime)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.coap.polyfill" id="apidoc.module.coap.polyfill">module coap.polyfill</a></h1>


    <h2>
        <a href="#apidoc.element.coap.polyfill.compareBuffers" id="apidoc.element.coap.polyfill.compareBuffers">
        function <span class="apidocSignatureSpan">coap.polyfill.</span>compareBuffers
        <span class="apidocSignatureSpan">(buf1, buf2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compareBuffers = function (buf1, buf2) {
  if (Buffer.compare)
    return Buffer.compare(buf1, buf2)
  else {
    if (buf1.length != buf2.length) return -1
    for (var i = 0; i &#x3c; buf1.length; i++) {
      if (buf1[i] != buf2[i]) return -1
    }
    return 0
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.coap.registerFormat" id="apidoc.module.coap.registerFormat">module coap.registerFormat</a></h1>


    <h2>
        <a href="#apidoc.element.coap.registerFormat.registerFormat" id="apidoc.element.coap.registerFormat.registerFormat">
        function <span class="apidocSignatureSpan">coap.</span>registerFormat
        <span class="apidocSignatureSpan">(name, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerFormat = function (name, value) {
  var bytes;

  if (value &#x3e; 255) {
    bytes = new Buffer(2);
    bytes.writeUInt16BE(value, 0);
  } else {
    bytes = new Buffer([value])
  }

  formatsString[name] = bytes
  formatsBinaries[value] = name
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### coap.ignoreOption(name)

Explicitly ignore an option; useful for compatibility with `http`-based
modules.

-------------------------------------------------------
&#x3c;a name=&#x22;registerFormat&#x22;&#x3e;&#x3c;/a&#x3e;
### coap.<span class="apidocCodeKeywordSpan">registerFormat</span>(name, value)

Register a new format to be interpreted and sent in CoAP
`Content-Format` option.
Each format is identified by a number, see the [Content-Format
registry](http://tools.ietf.org/html/draft-ietf-core-coap-18#section-12.3).

These are the defaults formats:
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.coap.registerOption" id="apidoc.module.coap.registerOption">module coap.registerOption</a></h1>


    <h2>
        <a href="#apidoc.element.coap.registerOption.registerOption" id="apidoc.element.coap.registerOption.registerOption">
        function <span class="apidocSignatureSpan">coap.</span>registerOption
        <span class="apidocSignatureSpan">(name, toBinary, fromBinary)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerOption = function (name, toBinary, fromBinary) {
  optionFromBinaryFunctions[name] = fromBinary
  optionToBinaryFunctions[name] = toBinary
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

#### reset()
Returns a Reset COAP Message to the sender. The RST message will appear as an empty message with code `0.00` and the
reset flag set to `true` to the caller. This action ends the interaction with the caller.

-------------------------------------------------------
&#x3c;a name=&#x22;registerOption&#x22;&#x3e;&#x3c;/a&#x3e;
### coap.<span class="apidocCodeKeywordSpan">registerOption</span>(name, toBinary, toString)

Register a new option to be converted to string and added to the
`message.headers`.
`toBinary` is a function that accept a string and returns a `Buffer`.
`toString` is a function that accept a `Buffer` and returns a `String`.

-------------------------------------------------------
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.coap.request" id="apidoc.module.coap.request">module coap.request</a></h1>


    <h2>
        <a href="#apidoc.element.coap.request.request" id="apidoc.element.coap.request.request">
        function <span class="apidocSignatureSpan">coap.</span>request
        <span class="apidocSignatureSpan">(url)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">request = function (url) {
  var agent, req, ipv6

  if (typeof url === &#x27;string&#x27;)
    url = URL.parse(url)

  ipv6 = net.isIPv6(url.hostname || url.host)

  if (url.agent)
    agent = url.agent
  else if (url.agent === false &#x26;&#x26; !ipv6)
    agent = new Agent({ type: &#x27;udp4&#x27; })
  else if (url.agent === false &#x26;&#x26; ipv6)
    agent = new Agent({ type: &#x27;udp6&#x27; })
  else if (ipv6)
    agent = exports.globalAgentIPv6
  else
    agent = exports.globalAgent

  return agent.request(url)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

server.on(&#x27;request&#x27;, function(req, res) {
res.end(&#x27;Hello &#x27; + req.url.split(&#x27;/&#x27;)[1] + &#x27;\n&#x27;)
})

// the default CoAP port is 5683
server.listen(function() {
var req = coap.<span class="apidocCodeKeywordSpan">request</span>(&#x27;coap://localhost/Matteo&#x27;)

req.on(&#x27;response&#x27;, function(res) {
  res.pipe(process.stdout)
  res.on(&#x27;end&#x27;, function() {
    process.exit(0)
  })
})
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.coap.retry_send" id="apidoc.module.coap.retry_send">module coap.retry_send</a></h1>


    <h2>
        <a href="#apidoc.element.coap.retry_send.retry_send" id="apidoc.element.coap.retry_send.retry_send">
        function <span class="apidocSignatureSpan">coap.</span>retry_send
        <span class="apidocSignatureSpan">(sock, port, host)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RetrySend(sock, port, host) {
  if (!(this instanceof RetrySend))
    return new RetrySend(port, host)

  var that    = this

  this._sock  = sock

  this._port  = port || parameters.coapPort

  this._host  = host

  this._sendAttemp = 0
  this._lastMessageId = -1
  this._currentTime = parameters.ackTimeout * (1 + (parameters.ackRandomFactor - 1) * Math.random()) * 1000

  this._bOff  = function() {
    that._currentTime = that._currentTime * 2
    that._send()
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.retry_send.super_" id="apidoc.element.coap.retry_send.super_">
        function <span class="apidocSignatureSpan">coap.retry_send.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.coap.retry_send.prototype" id="apidoc.module.coap.retry_send.prototype">module coap.retry_send.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.coap.retry_send.prototype._send" id="apidoc.element.coap.retry_send.prototype._send">
        function <span class="apidocSignatureSpan">coap.retry_send.prototype.</span>_send
        <span class="apidocSignatureSpan">(avoidBackoff)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_send = function (avoidBackoff) {
  var that = this

  this._sock.send(this._message, 0, this._message.length,
                  this._port, this._host, function(err, bytes) {
                    that.emit(&#x27;sent&#x27;, err, bytes)
                    if (err) {
                      that.emit(&#x27;error&#x27;, err)
                    }
                  })

  var messageId = parse(this._message).messageId
  if (messageId != this._lastMessageId) {
    this._lastMessageId = messageId
    this._sendAttemp = 0
  }

  if (!avoidBackoff &#x26;&#x26; ++this._sendAttemp &#x3c;= parameters.maxRetransmit)
    this._bOffTimer = setTimeout(this._bOff, this._currentTime)

  this.emit(&#x27;sending&#x27;, this._message)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  done()
}

ObserveWriteStream.prototype._doSend = function doSend(data) {
  var packet = this._packet
  packet.code = this.statusCode
  packet.payload = data
  this.<span class="apidocCodeKeywordSpan">_send</span>(this, packet)

  this._packet.confirmable = this._request.confirmable
  this._packet.ack = !this._request.confirmable
  delete this._packet.messageId
  delete this._packet.payload
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.retry_send.prototype.reset" id="apidoc.element.coap.retry_send.prototype.reset">
        function <span class="apidocSignatureSpan">coap.retry_send.prototype.</span>reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reset = function () {
  clearTimeout(this._timer)
  clearTimeout(this._bOffTimer)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
them by adding a `req.setOption(&#x27;Block2&#x27;, new Buffer([0x2]))` to the
output of [request](#request).

See the
[spec](http://tools.ietf.org/html/draft-ietf-core-coap-18#section-5.4)
for all the possible options.

#### message.<span class="apidocCodeKeywordSpan">reset</span>()
Returns a Reset COAP Message to the sender. The RST message will appear as an empty message with code `0.00` and the
reset flag set to `true` to the caller. This action ends the interaction with the caller.

#### message.writeHead(code, headers)
Functions somewhat like `http`&#x27;s `writeHead()` function.  If `code` is does not match the CoAP code mask of `#.##`, it is coerced
 into this mask.  `headers` is an object with keys being the header names, and values being the header values.

-------------------------------------------------------
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.coap.retry_send.prototype.send" id="apidoc.element.coap.retry_send.prototype.send">
        function <span class="apidocSignatureSpan">coap.retry_send.prototype.</span>send
        <span class="apidocSignatureSpan">(message, avoidBackoff)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">send = function (message, avoidBackoff) {
  var that = this
    , timeout

  this._message = message
  this._send(avoidBackoff)

  timeout = avoidBackoff ? parameters.maxRTT : parameters.exchangeLifetime
  this._timer = setTimeout(function() {
    var err  = new Error(&#x27;No reply in &#x27; + timeout + &#x27;s&#x27;)
    err.retransmitTimeout = timeout;
    if (!avoidBackoff)
      that.emit(&#x27;error&#x27;, err)
    that.emit(&#x27;timeout&#x27;, err)
  }, timeout * 1000)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

util.inherits(RetrySend, EventEmitter)

RetrySend.prototype._send = function(avoidBackoff) {
var that = this

this._sock.<span class="apidocCodeKeywordSpan">send</span>(this._message, 0, this._message.length,
                this._port, this._host, function(err, bytes) {
                  that.emit(&#x27;sent&#x27;, err, bytes)
                  if (err) {
                    that.emit(&#x27;error&#x27;, err)
                  }
                })
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.coap.updateTiming" id="apidoc.module.coap.updateTiming">module coap.updateTiming</a></h1>


    <h2>
        <a href="#apidoc.element.coap.updateTiming.updateTiming" id="apidoc.element.coap.updateTiming.updateTiming">
        function <span class="apidocSignatureSpan">coap.</span>updateTiming
        <span class="apidocSignatureSpan">(values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateTiming = function (values) {
  for (var key in values){
    if (p[key]) {
      p[key] = values[key]
    }
  }

  // MAX_TRANSMIT_SPAN is the maximum time from the first transmission
  // of a Confirmable message to its last retransmission.
  p.maxTransmitSpan = p.ackTimeout * ((Math.pow(2, p.maxRetransmit)) - 1) * p.ackRandomFactor

  // MAX_TRANSMIT_WAIT is the maximum time from the first transmission
  // of a Confirmable message to the time when the sender gives up on
  // receiving an acknowledgement or reset.
  p.maxTransmitWait = p.ackTimeout * (Math.pow(2, p.maxRetransmit + 1) - 1) * p.ackRandomFactor

  // PROCESSING_DELAY is the time a node takes to turn around a
  // Confirmable message into an acknowledgement.
  p.processingDelay = p.ackTimeout

  // MAX_RTT is the maximum round-trip time
  p.maxRTT = 2 * p.maxLatency + p.processingDelay

  //  EXCHANGE_LIFETIME is the time from starting to send a Confirmable
  //  message to the time when an acknowledgement is no longer expected,
  //  i.e.  message layer information about the message exchange can be
  //  purged
  p.exchangeLifetime = p.maxTransmitSpan + p.maxRTT

  // LRU prune timer period.
  // In order to reduce unnecessary heap usage on low-traffic servers the
  // LRU cache is periodically pruned to remove old, expired packets. This
  // is a fairly low-intensity task, but the period can be altered here
  // or the timer disabled by setting the value to zero.
  // By default the value is set to 0.5 x exchangeLifetime (~120s)
  if (values &#x26;&#x26; (typeof(values.pruneTimerPeriod)===&#x22;number&#x22;)) {
    p.pruneTimerPeriod = values.pruneTimerPeriod
  } else {
    p.pruneTimerPeriod =  (0.5 * p.exchangeLifetime)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var coapTiming = {
  ackTimeout:0.25,
  ackRandomFactor: 1.0,
  maxRetransmit: 3,
  maxLatency: 2,
  piggybackReplyMs: 10
};
coap.<span class="apidocCodeKeywordSpan">updateTiming</span>(coapTiming);
```

-------------------------------------------------------
&#x3c;a name=&#x22;defaultTiming&#x22;&#x3e;&#x3c;/a&#x3e;
### coap.defaultTiming

Reset the CoAP timings to the default values
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
